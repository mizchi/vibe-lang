# TODO

---

ユーザー編集エリア。CLAUDE は編集しない。

## 基本哲学

- この言語では試行錯誤の速度を最大化する
  - shell/repl を中心し設計して、ワンライナーを集積してコードを完成させる。nushell 風のシェルを持つ
  - Incremental な型チェックとコンパイラを持ち、依存が追跡される
  - 構文は Unison 言語を参考に Effect が組み込まれた Haskell の ML 風の構文で純粋関数を蓄積して、最終的にそれらの依存管理して必要なものを払い出し、最終コードを完成させる
- 推論可能で明示的な副作用コントロール
  - Effect System によるエフェクトの追跡して、実行前に要求パーミッションがわかる
  - Deno 風のパーミッションを明示的な許可を統合して、WASI Runtime として制御する
  - WebAssembly をファーストターゲットとして、WASI のサンドボックスで権限を制御する

## アイデア

- [x] vibe-mcp => mcp, vibe-lsp => lsp, vibe-test => test_runner として vsh の下に統合
- [x] コメント記法を `--` から `#` に変更
  - 複数行コメントは ### ### とする
- [ ] vsh
  - `vsh code.vibe` の場合、 main ... を自動実行する
  - `vsh test code.vibe` でテストが実行できる
  - vibe/shell/ の下に汎用シェルとしてのコマンドを用意する
    - これは起動時の権限で Read/Write/IO が制御される
  - [ ] formatter
    - コードベースに保存するときに AST としてかくのうするが、それが常に同じ結果になるように整形する
    - コードベースから AST を取り出して、ユーザーに表示する時にも使う
- [ ] Compiler
  - プリミティブな API セットを wasm のプリミティブと合わせておき、ビルドサイズを抑えられるようにする
- [ ] import の構文をファイルパス変更
  - 相対パス foo/bar.vibe の xxx に対して import ./foo/bar (xxx, yyy)
  - 基本的には関数一つが保存されるとする
  - wasm component model と統合するときのインターフェースを考慮しておく
- [ ] vibe-codebase
  - ucm を参考にコード操作体系を設計する
  - AST に Typed IR として推論結果を保持して、検索時はそれを参考にする

## ICEBOX

- [ ] 関数のシグネチャの変更の追跡で、 Semantic Versioning を自動化したい。
  - ドキュメンテーションや非破壊な変更なら patch
  - 過去のテストが落ち、型や関数が下位互換性のある変更なら minor
  - 公開済みの関数の破壊的な変更なら major
- [ ] vibe-core は wasm-pack でコンパイルできるような純粋なロジックとして、fs を mock すれば動くとする
- [ ] vibe-runtime は、deno permissions のように権限を管理する仕組みを持つ
- [ ] ある程度枯れたら、実用性を判定するために、vibe 言語によって、いくつかのライブラリを実装して評価
  - [ ] React / ELM 風の UI ライブラリを実装する
  - [ ] JSONSchema Checker を実装する
  - [ ] MCP Client
- [ ] Debugger
- [ ] TypeScript 型定義を生成
- [ ] AI Builtin (Claude Code)

---

ここから CLAUDE が編集していいエリア

## 実装完了 ✅

### 最近完了した機能（2024 年 12 月）

- ✅ 省略可能なパラメータ（`param?:Type?`）
- ✅ Option 型の糖衣構文（`String?` = `Option<String>`）
- ✅ 新しい関数定義構文（`let func x:Int y:Int -> Int = x + y`）
- ✅ ハッシュ参照（`#abc123`）
- ✅ バージョン指定インポート（`import Math@abc123`）
- ✅ 型推論結果の自動埋め込み
- ✅ 型定義の依存関係追跡
- ✅ pretty_print での型注釈表示

### 以前に完了した機能

- ✅ lowerCamelCase 命名規則の強制（ハイフンを禁止）
- ✅ 階層的な名前空間システム（Unison UCM 風）
- ✅ 関数単位の依存関係追跡
- ✅ AST コマンドによる構造的変換
- ✅ インクリメンタル型チェック
- ✅ 差分テスト実行システム
- ✅ 配列のパターンマッチ（`(list h ... t)` 形式）
- ✅ レコード（オブジェクトリテラル）とフィールドアクセス
- ✅ 構造化検索（型・AST・依存関係による検索）
- ✅ エフェクトシステム（基本実装）
- ✅ `perform` 構文
- ✅ セマンティック解析フェーズ
- ✅ `==` 演算子サポート

## 今後の実装計画（AI 時代の言語設計）

### 次の優先実装項目 🚀

#### 1. エフェクトシステムの完成（1-2 週間）

- [ ] do 記法のパーサー実装
  - `do { x <- perform State.get; perform State.put (x + 1) }`
- [ ] handle/with 構文の実装
  - `handle expr with { State.get () k -> k 0 0 }`
- [ ] エフェクトハンドラーの除去ロジック
- [ ] 関数型でのエフェクト表示（`Int -> <IO> String`）
- [ ] エフェクト多相関数のサポート

#### 2. シェルテストの拡充（1 週間）

- [ ] shell_e2e_test.rs の完成
- [ ] 対話的コマンドのテスト
- [ ] エラーハンドリングのテスト
- [ ] 複雑なシナリオのテスト

#### 3. 構造化シェルのパイプライン（2 週間）

- [ ] パイプライン演算子 `|>` の実装
- [ ] 標準的なコレクション操作（filter, map, reduce）
- [ ] 構造化データの表示改善
- [ ] JSON/YAML 出力サポート

### Phase 1: コード検索の強化 (1-2 週間) 🔍 【完了】

#### AST/型によるクエリシステム

- [x] 型パターンによる検索（例: "Int -> Int 型の関数を全て検索"） ✅
- [x] AST 構造による検索（例: "match 式を含む関数"） ✅
- [x] 依存関係による検索（DependsOn/DependedBy） ✅
- [x] REPL での検索コマンド（`search`, `find`） ✅
- [x] 検索結果の構造化表示 ✅

```lisp
; 使用例
xs> search type:(-> Int Int)
xs> find ast:match
xs> search dependsOn:Math.fibonacci
```

### Phase 2: 構造化シェルの拡張 (2-3 週間) 🐚

#### nushell 風のパイプライン処理

- [ ] パイプライン演算子 `|` の実装
- [ ] 構造化データの変換関数（filter, map, sort, where）
- [ ] inspect コマンドで詳細情報表示
- [ ] JSON/YAML 形式での入出力

```lisp
; 使用例
xs> definitions
    | filter (fn (d) (isFunction d.type))
    | map (fn (d) d.name)
    | sort

xs> inspect Math.fibonacci
{
  hash: "abc123...",
  type: "(-> Int Int)",
  dependencies: ["Math.add"],
  metadata: { ... }
}
```

### Phase 3: Effect System (3-4 週間) 🎯 【基本実装完了】

#### 副作用の型レベル追跡

- [x] Effect 型の定義（IO, Network, FileSystem 等） ✅
- [x] 関数からの Effect 推論 ✅
- [x] Effect 注釈の構文（基本実装） ✅
- [x] 純粋関数との明確な区別 ✅

```lisp
; Effect使用例（現在の構文）
let hello = fn () -> perform IO "Hello, World!"
let divide = fn x y ->
  if y == 0 {
    perform Exception "Division by zero"
  } else {
    x / y
  }
```

#### 残りのタスク

- [ ] do 記法の完全サポート
- [ ] ハンドラー構文の実装
- [ ] エフェクト多相性の完全実装
- [ ] 関数型でのエフェクト表示（`Int -> IO String`など）

### Phase 4: 実行権限システム (2 週間) 🔒

#### Effect 推論からの権限導出

- [ ] Permission 型の定義
- [ ] Effect→Permission 自動変換
- [ ] CLI での権限指定（--allow-io, --deny-net 等）
- [ ] サンドボックス実行環境

```bash
# 実行例
vsh run --deny-io program.xs  # IOエフェクトがあればエラー
vsh run --allow-read=/tmp program.xs  # /tmpのみ読み取り許可
```

### Phase 5: AI 統合の強化 (継続的) 🤖

#### MCP プロトコル対応

- [ ] 型情報の直接提供 API
- [ ] AST 操作 API（AST コマンドの拡張）
- [ ] 依存関係グラフ API
- [ ] インクリメンタル更新通知

#### AI 向け機能

- [ ] 関数の使用例自動生成
- [ ] 型シグネチャからの説明生成
- [ ] エラーからの自動修正提案
- [ ] テスト失敗からの実装推論

## その他の改善項目

### 標準ライブラリ

- [ ] IO 操作（ファイル読み書き）
- [ ] ネットワーク操作
- [ ] JSON/YAML パーサー
- [ ] 正規表現
- [ ] 日付/時刻操作

### 開発者体験

- [ ] LSP (Language Server Protocol) サポート
- [ ] デバッガー統合
- [ ] より詳細なプロファイラー

### パフォーマンス

- [ ] 型チェッカーの更なる高速化
- [ ] WebAssembly コード生成の最適化

## セルフホスティングの段階的実装 🔄

### 現状

- `xs/parser/`, `xs/checker/`, `xs/tests/` ディレクトリに S 式形式の実装が存在
- これらは将来的に XS 言語自身で書かれたセルフホスティング実装になる予定
- 現在はまだ実験的な段階のため、S 式形式のまま保持

### Phase 1: パーサーのセルフホスティング (2-3 ヶ月)

- [ ] xs/parser/lexer.xs - レキサーの実装
- [ ] xs/parser/parser.xs - パーサーの実装
- [ ] S 式形式から新構文への段階的移行
- [ ] Rust の現行パーサーとの出力比較テスト

### Phase 2: 型チェッカーのセルフホスティング (3-4 ヶ月)

- [ ] xs/checker/types.xs - 型システムの実装
- [ ] xs/checker/checker.xs - 型チェッカーの実装
- [ ] HM 型推論アルゴリズムの再実装
- [ ] 型エラーメッセージの改善

### Phase 3: コンパイラバックエンドの移植 (4-6 ヶ月)

- [ ] WebAssembly コード生成
- [ ] 最適化パスの実装
- [ ] ランタイムシステムとの統合

### 移行戦略

1. **段階的移行**: 各モジュールを個別に移植し、既存実装と並行実行
2. **差分テスト**: 新旧実装の出力を比較し、互換性を保証
3. **パフォーマンス監視**: セルフホスティング版のパフォーマンスを継続的に測定
4. **フォールバック**: 問題が発生した場合は Rust 実装にフォールバック可能に

### メリット

- XS 言語の実用性の証明
- 言語仕様の正確な文書化
- AI による言語実装の理解と拡張が容易に
- ドッグフーディングによる言語設計の改善

## 既知の問題と修正予定 🐛

### パーサー関連

- [x] parser が`let ... in`の後の改行を正しく処理できない ✅
  - 現状: `let x = 1 in\nx + 1` がパースエラーになる
  - 対策: 改行のトークン処理を修正
  - 実装済み: `skip_newlines()`を適切な箇所に追加
- [x] コメント構文が未実装 ✅
  - 現状: `--` や `{- -}` などのコメントが使えない
  - 対策: レキサーにコメントトークンを追加
  - 実装済み: `#`による行コメントと`### ###`による複数行コメント対応
- [ ] トップレベルでの数値リテラルの扱いに問題
  - 現状: `name 5` のような式でパースエラー
  - 対策: パーサーの式認識を改善

### 言語機能

- [x] 再帰関数定義の新しい構文が必要 ✅
  - 現状: `rec`キーワードが削除されたため再帰関数が定義できない
  - 対策: `letrec`構文の実装または Y combinator のサポート
  - 実装済み: `letrec name args = body in expr`構文を追加
- [x] ==演算子のサポート ✅
  - 実装済み: レキサー、パーサー、型チェッカー、ランタイムで対応
- [x] match 構文の統一 ✅
  - `case`キーワードを廃止し、`match`のみを使用
  - `of`キーワードを完全削除（`match expr { ... }`形式に統一）
- [x] セマンティック解析フェーズの実装 ✅
  - パース後に特殊フォームを検証
  - ブロックごとのエフェクト権限管理
  - スコープとキャプチャの解析
- [ ] 統一文法の完全実装（Unified Grammar Design）
  - 現状: 特殊構文（match、do、handle）が個別にパースされている
  - 対策: keyword_form として統一的に扱い、セマンティック解析で検証
  - 利点: パーサーの簡素化、エラーメッセージの改善、IDE 対応の容易化
- [ ] do 記法での複雑な構文サポート
  - 現状: `do { ... }` 形式のモナド的構文が未実装
  - 対策: パーサーの拡張とデシュガリング実装
- [ ] ハンドラー構文の完全実装
  - 現状: `handle ... with` 構文が部分的にしか動作しない
  - 対策: パーサーとランタイムでの完全サポート

### ツール関連

- [ ] SQLite の FOREIGN KEY 制約エラー
  - 現状: コードリポジトリ使用時に警告が出る（動作には影響なし）
  - 対策: データベーススキーマの修正またはトランザクション管理の改善
