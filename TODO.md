# TODO

## 既存のアイデア

- [x] 配列のパターンマッチ `[]`, `[head, ...tail]` を導入する ✅
  - パーサー、型チェッカー、インタープリターすべてで実装済み
  - `(list h ... t)` 形式でhead/tailパターンマッチが可能
- [x] リテラルの中に `{ x: 1 }` のようなオブジェクトリテラルを導入する ✅
  - レコード型として既に実装済み
  - `{ name: "Alice", age: 30 }` のような構文でレコードを作成
  - `person.name` のようなドット記法でフィールドアクセス可能
- [ ] Rust のように、実装と同じファイルで In Source Testing ができる
  - 検討の結果、S式ベースの言語では標準ライブラリとして実装するのが適切
  - 将来的には、テストフレームワーク（xs-test）の拡張として実装予定

## 実装完了 ✅

### 最近完了した機能（2024年12月）
- ✅ 省略可能なパラメータ（`param?:Type?`）
- ✅ Option型の糖衣構文（`String?` = `Option<String>`）
- ✅ 新しい関数定義構文（`let func x:Int y:Int -> Int = x + y`）
- ✅ ハッシュ参照（`#abc123`）
- ✅ バージョン指定インポート（`import Math@abc123`）
- ✅ 型推論結果の自動埋め込み
- ✅ 型定義の依存関係追跡
- ✅ pretty_printでの型注釈表示

### 以前に完了した機能
- ✅ lowerCamelCase命名規則の強制（ハイフンを禁止）
- ✅ 階層的な名前空間システム（Unison UCM風）
- ✅ 関数単位の依存関係追跡
- ✅ ASTコマンドによる構造的変換
- ✅ インクリメンタル型チェック
- ✅ 差分テスト実行システム
- ✅ 配列のパターンマッチ（`(list h ... t)` 形式）
- ✅ レコード（オブジェクトリテラル）とフィールドアクセス
- ✅ 構造化検索（型・AST・依存関係による検索）
- ✅ エフェクトシステム（基本実装）
- ✅ `perform` 構文
- ✅ セマンティック解析フェーズ
- ✅ `==` 演算子サポート

## 今後の実装計画（AI時代の言語設計）

### 次の優先実装項目 🚀

#### 1. エフェクトシステムの完成（1-2週間）
- [ ] do記法のパーサー実装
  - `do { x <- perform State.get; perform State.put (x + 1) }`
- [ ] handle/with構文の実装
  - `handle expr with { State.get () k -> k 0 0 }`
- [ ] エフェクトハンドラーの除去ロジック
- [ ] 関数型でのエフェクト表示（`Int -> <IO> String`）
- [ ] エフェクト多相関数のサポート

#### 2. シェルテストの拡充（1週間）
- [ ] shell_e2e_test.rsの完成
- [ ] 対話的コマンドのテスト
- [ ] エラーハンドリングのテスト
- [ ] 複雑なシナリオのテスト

#### 3. 構造化シェルのパイプライン（2週間）
- [ ] パイプライン演算子 `|>` の実装
- [ ] 標準的なコレクション操作（filter, map, reduce）
- [ ] 構造化データの表示改善
- [ ] JSON/YAML出力サポート

### Phase 1: コード検索の強化 (1-2週間) 🔍 【完了】

#### AST/型によるクエリシステム
- [x] 型パターンによる検索（例: "Int -> Int型の関数を全て検索"） ✅
- [x] AST構造による検索（例: "match式を含む関数"） ✅
- [x] 依存関係による検索（DependsOn/DependedBy） ✅
- [x] REPLでの検索コマンド（`search`, `find`） ✅
- [x] 検索結果の構造化表示 ✅

```lisp
; 使用例
xs> search type:(-> Int Int)
xs> find ast:match
xs> search dependsOn:Math.fibonacci
```

### Phase 2: 構造化シェルの拡張 (2-3週間) 🐚

#### nushell風のパイプライン処理
- [ ] パイプライン演算子 `|` の実装
- [ ] 構造化データの変換関数（filter, map, sort, where）
- [ ] inspectコマンドで詳細情報表示
- [ ] JSON/YAML形式での入出力

```lisp
; 使用例
xs> definitions 
    | filter (fn (d) (isFunction d.type))
    | map (fn (d) d.name)
    | sort

xs> inspect Math.fibonacci
{
  hash: "abc123...",
  type: "(-> Int Int)",
  dependencies: ["Math.add"],
  metadata: { ... }
}
```

### Phase 3: Effect System (3-4週間) 🎯 【基本実装完了】

#### 副作用の型レベル追跡
- [x] Effect型の定義（IO, Network, FileSystem等） ✅
- [x] 関数からのEffect推論 ✅
- [x] Effect注釈の構文（基本実装） ✅
- [x] 純粋関数との明確な区別 ✅

```lisp
; Effect使用例（現在の構文）
let hello = fn () -> perform IO "Hello, World!"
let divide = fn x y ->
  if y == 0 {
    perform Exception "Division by zero"
  } else {
    x / y
  }
```

#### 残りのタスク
- [ ] do記法の完全サポート
- [ ] ハンドラー構文の実装
- [ ] エフェクト多相性の完全実装
- [ ] 関数型でのエフェクト表示（`Int -> IO String`など）

### Phase 4: 実行権限システム (2週間) 🔒

#### Effect推論からの権限導出
- [ ] Permission型の定義
- [ ] Effect→Permission自動変換
- [ ] CLIでの権限指定（--allow-io, --deny-net等）
- [ ] サンドボックス実行環境

```bash
# 実行例
xs run --deny-io program.xs  # IOエフェクトがあればエラー
xs run --allow-read=/tmp program.xs  # /tmpのみ読み取り許可
```

### Phase 5: AI統合の強化 (継続的) 🤖

#### MCPプロトコル対応
- [ ] 型情報の直接提供API
- [ ] AST操作API（ASTコマンドの拡張）
- [ ] 依存関係グラフAPI
- [ ] インクリメンタル更新通知

#### AI向け機能
- [ ] 関数の使用例自動生成
- [ ] 型シグネチャからの説明生成
- [ ] エラーからの自動修正提案
- [ ] テスト失敗からの実装推論

## その他の改善項目

### 標準ライブラリ
- [ ] IO操作（ファイル読み書き）
- [ ] ネットワーク操作
- [ ] JSON/YAMLパーサー
- [ ] 正規表現
- [ ] 日付/時刻操作

### 開発者体験
- [ ] LSP (Language Server Protocol) サポート
- [ ] デバッガー統合
- [ ] より詳細なプロファイラー

### パフォーマンス
- [ ] 型チェッカーの更なる高速化
- [ ] WebAssemblyコード生成の最適化

## セルフホスティングの段階的実装 🔄

### 現状
- `xs/parser/`, `xs/checker/`, `xs/tests/` ディレクトリにS式形式の実装が存在
- これらは将来的にXS言語自身で書かれたセルフホスティング実装になる予定
- 現在はまだ実験的な段階のため、S式形式のまま保持

### Phase 1: パーサーのセルフホスティング (2-3ヶ月)
- [ ] xs/parser/lexer.xs - レキサーの実装
- [ ] xs/parser/parser.xs - パーサーの実装  
- [ ] S式形式から新構文への段階的移行
- [ ] Rustの現行パーサーとの出力比較テスト

### Phase 2: 型チェッカーのセルフホスティング (3-4ヶ月)
- [ ] xs/checker/types.xs - 型システムの実装
- [ ] xs/checker/checker.xs - 型チェッカーの実装
- [ ] HM型推論アルゴリズムの再実装
- [ ] 型エラーメッセージの改善

### Phase 3: コンパイラバックエンドの移植 (4-6ヶ月)
- [ ] WebAssemblyコード生成
- [ ] 最適化パスの実装
- [ ] ランタイムシステムとの統合

### 移行戦略
1. **段階的移行**: 各モジュールを個別に移植し、既存実装と並行実行
2. **差分テスト**: 新旧実装の出力を比較し、互換性を保証
3. **パフォーマンス監視**: セルフホスティング版のパフォーマンスを継続的に測定
4. **フォールバック**: 問題が発生した場合はRust実装にフォールバック可能に

### メリット
- XS言語の実用性の証明
- 言語仕様の正確な文書化
- AIによる言語実装の理解と拡張が容易に
- ドッグフーディングによる言語設計の改善

## 既知の問題と修正予定 🐛

### パーサー関連
- [x] parserが`let ... in`の後の改行を正しく処理できない ✅
  - 現状: `let x = 1 in\nx + 1` がパースエラーになる
  - 対策: 改行のトークン処理を修正
  - 実装済み: `skip_newlines()`を適切な箇所に追加
- [x] コメント構文が未実装 ✅
  - 現状: `--` や `{- -}` などのコメントが使えない
  - 対策: レキサーにコメントトークンを追加
  - 実装済み: `--`による行コメント対応
- [ ] トップレベルでの数値リテラルの扱いに問題
  - 現状: `name 5` のような式でパースエラー
  - 対策: パーサーの式認識を改善

### 言語機能
- [x] 再帰関数定義の新しい構文が必要 ✅
  - 現状: `rec`キーワードが削除されたため再帰関数が定義できない
  - 対策: `letrec`構文の実装またはY combinatorのサポート
  - 実装済み: `letrec name args = body in expr`構文を追加
- [x] ==演算子のサポート ✅
  - 実装済み: レキサー、パーサー、型チェッカー、ランタイムで対応
- [x] match構文の統一 ✅
  - `case`キーワードを廃止し、`match`のみを使用
  - `of`キーワードを完全削除（`match expr { ... }`形式に統一）
- [x] セマンティック解析フェーズの実装 ✅
  - パース後に特殊フォームを検証
  - ブロックごとのエフェクト権限管理
  - スコープとキャプチャの解析
- [ ] 統一文法の完全実装（Unified Grammar Design）
  - 現状: 特殊構文（match、do、handle）が個別にパースされている
  - 対策: keyword_form として統一的に扱い、セマンティック解析で検証
  - 利点: パーサーの簡素化、エラーメッセージの改善、IDE対応の容易化
- [ ] do記法での複雑な構文サポート
  - 現状: `do { ... }` 形式のモナド的構文が未実装
  - 対策: パーサーの拡張とデシュガリング実装
- [ ] ハンドラー構文の完全実装
  - 現状: `handle ... with` 構文が部分的にしか動作しない
  - 対策: パーサーとランタイムでの完全サポート

### ツール関連
- [ ] SQLiteのFOREIGN KEY制約エラー
  - 現状: コードリポジトリ使用時に警告が出る（動作には影響なし）
  - 対策: データベーススキーマの修正またはトランザクション管理の改善
