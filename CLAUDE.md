# Vibe Language - AI å‘ã‘é«˜é€Ÿé™çš„è§£æè¨€èª

## æ¦‚è¦

Vibe è¨€èªã¯ã€AI ãŒç†è§£ãƒ»è§£æã—ã‚„ã™ã„ã‚ˆã†ã«è¨­è¨ˆã•ã‚ŒãŸé™çš„å‹ä»˜ãé–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã™ã€‚ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¢ãƒ‰ãƒ¬ã‚¹å‹ã®ã‚³ãƒ¼ãƒ‰ç®¡ç†ã€ç´”ç²‹é–¢æ•°å‹è¨­è¨ˆã€ãã—ã¦ AI ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã‚ˆã‚Šã€AI ã«ã‚ˆã‚‹ã‚³ãƒ¼ãƒ‰ç†è§£ã¨ç”Ÿæˆã‚’æœ€é©åŒ–ã—ã¾ã™ã€‚

## è¨€èªã®ç‰¹å¾´

### 1. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¢ãƒ‰ãƒ¬ã‚¹å‹ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ï¼ˆUnison é¢¨ï¼‰

- ã™ã¹ã¦ã®å¼ãŒ SHA256 ãƒãƒƒã‚·ãƒ¥ã§ä¸€æ„ã«è­˜åˆ¥ã•ã‚Œã‚‹
- åŒã˜ã‚³ãƒ¼ãƒ‰ã¯å¸¸ã«åŒã˜ãƒãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆï¼ˆæ±ºå®šè«–çš„ï¼‰
- å¤‰æ›´ã®è¿½è·¡ãŒå®¹æ˜“ã§ã€AI ãŒå·®åˆ†ã‚’åŠ¹ç‡çš„ã«ç†è§£ã§ãã‚‹
- UCMï¼ˆUnison Codebase Managerï¼‰é¢¨ã® edit/update æ©Ÿèƒ½

### 2. ç´”ç²‹é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°

- å‰¯ä½œç”¨ã®ãªã„ç´”ç²‹é–¢æ•°ã®ã¿
- è‡ªå‹•ã‚«ãƒªãƒ¼åŒ–ã«ã‚ˆã‚‹éƒ¨åˆ†é©ç”¨
- å‚ç…§é€éæ€§ã«ã‚ˆã‚Šã€AI ãŒé–¢æ•°ã®æŒ¯ã‚‹èˆã„ã‚’ç¢ºå®Ÿã«äºˆæ¸¬å¯èƒ½
- Perceus å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªãƒ¡ãƒ¢ãƒªç®¡ç†

### 3. Haskell é¢¨æ§‹æ–‡ã¨ãƒ–ãƒ­ãƒƒã‚¯ã‚¹ã‚³ãƒ¼ãƒ—

- ã‚·ã‚§ãƒ«ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªèª­ã¿ã‚„ã™ã„æ§‹æ–‡
- ãƒ–ãƒ­ãƒƒã‚¯ã‚¹ã‚³ãƒ¼ãƒ—ã¨ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ¼”ç®—å­ã®ã‚µãƒãƒ¼ãƒˆ
- Haskell ã«åŸºã¥ã„ãŸå‹ã‚·ã‚¹ãƒ†ãƒ ã¨é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°

### 4. Hindley-Milner å‹æ¨è«–

- æ˜ç¤ºçš„ãªå‹æ³¨é‡ˆã‚’æœ€å°é™ã«
- å®Œå…¨ãªå‹æ¨è«–ã«ã‚ˆã‚Šã€AI ãŒå‹æƒ…å ±ã‚’æ´»ç”¨ã—ã‚„ã™ã„
- Let å¤šç›¸ã«ã‚ˆã‚‹æŸ”è»Ÿãªå‹ã‚·ã‚¹ãƒ†ãƒ 

### 5. AI ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

- æ§‹é€ åŒ–ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼æƒ…å ±ï¼ˆã‚«ãƒ†ã‚´ãƒªãƒ¼ã€ææ¡ˆã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼‰
- å‹å¤‰æ›ã®è‡ªå‹•ææ¡ˆ
- ãƒ¬ãƒ¼ãƒ™ãƒ³ã‚·ãƒ¥ã‚¿ã‚¤ãƒ³è·é›¢ã«ã‚ˆã‚‹é¡ä¼¼å¤‰æ•°åã®ææ¡ˆ
- ãƒˆãƒ¼ã‚¯ãƒ³åŠ¹ç‡çš„ãªè‹±èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆå°†æ¥çš„ã«å¤šè¨€èªåŒ–äºˆå®šï¼‰

### 6. åå‰ç©ºé–“ã‚·ã‚¹ãƒ†ãƒ 

- éšå±¤çš„ãªåå‰ç©ºé–“ï¼ˆ`Math.Utils.fibonacci`ï¼‰
- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ™ãƒ¼ã‚¹ã®ä¾å­˜é–¢ä¿‚ç®¡ç†
- åå‰ã®è§£æ±ºã¨ã‚¨ã‚¤ãƒªã‚¢ã‚¹æ©Ÿèƒ½
- ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ãªå†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«

### 7. æ§‹é€ çš„ã‚³ãƒ¼ãƒ‰å¤‰æ›

- AST ã‚³ãƒãƒ³ãƒ‰ã«ã‚ˆã‚‹å®‰å…¨ãªå¤‰æ›æ“ä½œ
- Replaceã€Renameã€Extractã€Wrap ãªã©ã®åŸºæœ¬æ“ä½œ
- å‹å®‰å…¨æ€§ã‚’ä¿è¨¼ã™ã‚‹å¤‰æ›
- AI ã‚„ãƒ„ãƒ¼ãƒ«ã‹ã‚‰ã®äºˆæ¸¬å¯èƒ½ãªæ“ä½œ

### 8. ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ ï¼ˆå®Ÿè£…ä¸­ï¼‰

- æ‹¡å¼µå¯èƒ½ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆExtensible Effectsï¼‰
- é–¢æ•°ãƒ¬ãƒ™ãƒ«ã§ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ¨è«–
- `perform`æ§‹æ–‡ã«ã‚ˆã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè¡Œ
- `handle/with`æ§‹æ–‡ã«ã‚ˆã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆå®Ÿè£…äºˆå®šï¼‰
- IOã€Stateã€Exceptionã€Async ãªã©ã®çµ„ã¿è¾¼ã¿ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ

### 9. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯è§£æãƒ•ã‚§ãƒ¼ã‚º

- ãƒ‘ãƒ¼ã‚¹å¾Œã®æ§‹é€ æ¤œè¨¼
- ãƒ–ãƒ­ãƒƒã‚¯ã”ã¨ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ¨©é™ç®¡ç†
- ã‚¹ã‚³ãƒ¼ãƒ—ã¨ã‚­ãƒ£ãƒ—ãƒãƒ£ã®è§£æ
- ç‰¹æ®Šãƒ•ã‚©ãƒ¼ãƒ ï¼ˆmatchã€doã€handleï¼‰ã®æ¤œè¨¼

### crate ã®æ§‹æˆ

- **vibe-language**: è¨€èªã‚³ã‚¢ï¼ˆAST å®šç¾©ã€å‹å®šç¾©ã€ãƒ‘ãƒ¼ã‚µãƒ¼ã€ãƒ—ãƒªãƒ†ã‚£ãƒ—ãƒªãƒ³ã‚¿ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®šç¾©ï¼‰
- **vibe-compiler**: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ï¼ˆå‹ãƒã‚§ãƒƒã‚«ãƒ¼ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ¨è«–ã€ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯è§£æã€ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–ï¼‰
- **vibe-runtime**: ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã€è©•ä¾¡å™¨ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ©ãƒ³ã‚¿ã‚¤ãƒ ï¼‰
- **vibe-codebase**: UCM é¢¨ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ç®¡ç†ï¼ˆã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã€ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã€ãƒ–ãƒ­ãƒƒã‚¯å±æ€§ç®¡ç†ï¼‰
- **vibe-shell**: çµ±åˆã‚·ã‚§ãƒ«ãƒ»REPLï¼ˆVibe Shellã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ï¼‰

### ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç®¡ç†

- AST ã¨ã¯åˆ¥ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚„ä¸€æ™‚å¤‰æ•°ãƒ©ãƒ™ãƒ«ã‚’ç®¡ç†
- NodeId ã«ã‚ˆã‚‹ä¸€æ„ãªè­˜åˆ¥
- ã‚³ãƒ¼ãƒ‰å±•é–‹æ™‚ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è€ƒæ…®ã—ãŸæ•´å½¢

## åŸºæœ¬æ§‹æ–‡

### å‘½åè¦å‰‡

- **lowerCamelCase**: å¤‰æ•°åã€é–¢æ•°åã¯ãƒã‚¤ãƒ•ãƒ³ãªã—ã® lowerCamelCase ã‚’ä½¿ç”¨
- ä¾‹: `strConcat`ã€`intToString`ã€`foldLeft`ï¼ˆ~~`str-concat`~~ã€~~`int-to-string`~~ã€~~`fold-left`~~ï¼‰

```haskell
# å¤‰æ•°å®šç¾©
let x = 42
let y : Int = 10  # å‹æ³¨é‡ˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

# é–¢æ•°å®šç¾©ï¼ˆè‡ªå‹•ã‚«ãƒªãƒ¼åŒ–ï¼‰
let add = fn x y -> x + y
let inc = add 1  # éƒ¨åˆ†é©ç”¨

# $æ¼”ç®—å­ï¼ˆä½å„ªå…ˆé †ä½é–¢æ•°é©ç”¨ï¼‰
print $ 1 + 2              # print (1 + 2)
map double $ [1, 2, 3]     # map double [1, 2, 3]
f $ g $ h x                # f (g (h x)) - å³çµåˆ

# letInæ§‹æ–‡ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
let x = 10 in x + 5  # çµæœ: 15
let x = 5 in
  let y = 10 in
    x * y  # çµæœ: 50

# å†å¸°é–¢æ•°
rec factorial n =
  if (eq n 0) {
    1
  } else {
    n * (factorial (n - 1))
  }

# recå†…ã§letInä½¿ç”¨ï¼ˆå†…éƒ¨ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼‰
rec quicksort lst =
  match lst {
    [] -> []
    pivot :: rest ->
      let smaller = filter (fn x -> x < pivot) rest in
      let larger = filter (fn x -> x >= pivot) rest in
        append (quicksort smaller) (cons pivot (quicksort larger))
  }

# letRecï¼ˆç›¸äº’å†å¸°å¯¾å¿œï¼‰
letRec even n = if (eq n 0) { true } else { odd (n - 1) }
letRec odd n = if (eq n 0) { false } else { even (n - 1) }

# ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ï¼ˆofã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ä¸è¦ï¼‰
match xs {
  [] -> 0                        # ç©ºãƒªã‚¹ãƒˆ
  [h] -> h                       # å˜ä¸€è¦ç´ 
  h :: t -> 1 + (length t)       # head/tailãƒ‘ã‚¿ãƒ¼ãƒ³
}

# è¤‡æ•°è¦ç´ ã¨æ®‹ã‚Šã®ãƒ‘ã‚¿ãƒ¼ãƒ³
match lst {
  [a, b, c, ...rest] -> a + b + c  # æœ€åˆã®3è¦ç´ ã‚’å–å¾—
  [x, y] -> x + y                   # 2è¦ç´ ã®ã¿
  _ -> 0                            # ãã®ä»–
}

# ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹
type Option a =
  | None
  | Some a

type Result e a =
  | Error e
  | Ok a

# ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
module Math {
  export add, multiply, factorial
  let add = fn x y -> x + y
  ...
}

# ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import Math
import List as L

# åå‰ç©ºé–“ã§ã®å®šç¾©
namespace Math.Utils {
  let fibonacci = rec fib n ->
    if n < 2 {
      n
    } else {
      (fib (n - 1)) + (fib (n - 2))
    }
}

# å®Œå…¨ä¿®é£¾åã§ã®ã‚¢ã‚¯ã‚»ã‚¹
Math.Utils.fibonacci 10

# ãƒ¬ã‚³ãƒ¼ãƒ‰ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«ï¼‰
let person = { name: "Alice", age: 30 }

# ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹
let name = person.name
let age = person.age

# ãƒã‚¹ãƒˆã—ãŸãƒ¬ã‚³ãƒ¼ãƒ‰
let company = {
  name: "TechCorp",
  address: { city: "Tokyo", zip: "100-0001" }
}

# ãƒã‚¹ãƒˆã—ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¢ã‚¯ã‚»ã‚¹
let city = company.address.city

# é–¢æ•°çš„ãªæ›´æ–°ï¼ˆæ–°ã—ã„ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆï¼‰
let updatedPerson = { name: "Bob", age: person.age }

# ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä½¿ç”¨ä¾‹
# performæ§‹æ–‡ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å®Ÿè¡Œ
let greet = fn name -> perform IO ("Hello, " ++ name)

# handleæ§‹æ–‡ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å‡¦ç†ï¼ˆå®Ÿè£…äºˆå®šï¼‰
handle {
  x <- perform State.get;
  perform State.put (x + 1);
  perform State.get
} {
  State.get () k -> k 0 0    # åˆæœŸçŠ¶æ…‹0ã‚’è¿”ã™
  State.put s k -> k () s    # çŠ¶æ…‹ã‚’æ›´æ–°
}
```

## æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª

### core.vibe

- åŸºæœ¬çš„ãªé–¢æ•°åˆæˆã€æ’ç­‰é–¢æ•°ã€å®šæ•°é–¢æ•°
- Maybe/Either å‹ã¨é–¢é€£é–¢æ•°
- ãƒ–ãƒ¼ãƒªã‚¢ãƒ³æ¼”ç®—ã€æ•°å€¤ãƒ˜ãƒ«ãƒ‘ãƒ¼

### list.vibe

- ãƒªã‚¹ãƒˆæ“ä½œ: map, filter, foldLeft, foldRight
- ãƒªã‚¹ãƒˆç”Ÿæˆ: range, replicate
- ãƒªã‚¹ãƒˆæ¤œç´¢: find, elem, all, any

### math.vibe

- æ•°å­¦é–¢æ•°: pow, factorial, gcd, lcm
- æ•°å€¤è¿°èª: even, odd, positive, negative
- çµ±è¨ˆé–¢æ•°: sum, product, average

### string.vibe

- æ–‡å­—åˆ—æ“ä½œ: concat, join, repeat
- æ–‡å­—åˆ—æ¯”è¼ƒ: strEq, strNeq
- æ–‡å­—åˆ—å¤‰æ›: intToString, stringToInt

## Vibe Shell (vsh)

### åŸºæœ¬ã‚³ãƒãƒ³ãƒ‰

- `help` - ãƒ˜ãƒ«ãƒ—è¡¨ç¤º
- `history [n]` - è©•ä¾¡å±¥æ­´è¡¨ç¤º
- `ls [pattern]` - åå‰ä»˜ãå¼ã®ä¸€è¦§ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ•ã‚£ãƒ«ã‚¿å¯¾å¿œï¼‰
- `search <query>` - å‹ãƒ»ASTãƒ»ä¾å­˜é–¢ä¿‚ã«ã‚ˆã‚‹æ¤œç´¢
- `find <pattern>` - åå‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã‚‹æ¤œç´¢
- `add <name> = <expr>` - å¼ã«åå‰ã‚’ä»˜ã‘ã¦è¿½åŠ 
- `view <name|hash>` - å®šç¾©ã®è¡¨ç¤º

### æ¤œç´¢æ©Ÿèƒ½

- `search type:Int->Int` - å‹ã«ã‚ˆã‚‹æ¤œç´¢
- `search ast:match` - AST æ§‹é€ ã«ã‚ˆã‚‹æ¤œç´¢
- `search dependsOn:foo` - ä¾å­˜é–¢ä¿‚ã«ã‚ˆã‚‹æ¤œç´¢

### ä½¿ç”¨ä¾‹

```
xs> let double = fn x -> x * 2
double : Int -> Int

xs> double 21
42

xs> add double_fn = fn x -> x * 2
Added double_fn

xs> search type:Int->Int
Found 3 definitions:
double : Int -> Int [bac2c0f3]
double_fn : Int -> Int [bac2c0f3]
inc : Int -> Int [def456ab]

xs> search ast:match
Found 2 definitions:
quicksort : List a -> List a [abc123de]
findFirst : (a -> Bool) -> List a -> Option a [fed987cb]
```

## ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¨­è¨ˆ

### ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒªãƒ¼

- **SYNTAX**: æ§‹æ–‡ã‚¨ãƒ©ãƒ¼
- **TYPE**: å‹ã‚¨ãƒ©ãƒ¼
- **SCOPE**: ã‚¹ã‚³ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼ï¼ˆæœªå®šç¾©å¤‰æ•°ãªã©ï¼‰
- **PATTERN**: ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚¨ãƒ©ãƒ¼
- **MODULE**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–¢é€£ã‚¨ãƒ©ãƒ¼
- **RUNTIME**: å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼

### ã‚¨ãƒ©ãƒ¼æ§‹é€ 

```
ERROR[TYPE]: Type mismatch: expected type 'Int', but found type 'String'
Location: line 3, column 5
Code: x + y
Type mismatch: expected Int, found String
Suggestions:
  1. Convert string to integer using 'int_of_string'
     Replace with: intOfString y
```

## å®Ÿè£…çŠ¶æ³

### å®Œäº†æ¸ˆã¿æ©Ÿèƒ½

- âœ… Haskell é¢¨ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆãƒ–ãƒ­ãƒƒã‚¯ã‚¹ã‚³ãƒ¼ãƒ—ã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ¼”ç®—å­ã€lowerCamelCase å¯¾å¿œï¼‰
- âœ… HM å‹æ¨è«–ï¼ˆå®Œå…¨ãªå‹æ¨è«–ã‚µãƒãƒ¼ãƒˆï¼‰
- âœ… åŸºæœ¬çš„ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼
- âœ… çµ±åˆ CLI ãƒ„ãƒ¼ãƒ« (vsh: parse/check/run/test/bench/shell)
- âœ… é«˜æ©Ÿèƒ½ REPL (Vibe Shell with æ¤œç´¢æ©Ÿèƒ½)
- âœ… ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¢ãƒ‰ãƒ¬ã‚¹å‹ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹
- âœ… è‡ªå‹•ã‚«ãƒªãƒ¼åŒ–ã¨éƒ¨åˆ†é©ç”¨
- âœ… æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆcore, list, math, stringï¼‰
- âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ï¼ˆ`::` æ¼”ç®—å­ã€ãƒªã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- âœ… ãƒ¬ã‚³ãƒ¼ãƒ‰å‹ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ†ãƒ©ãƒ«ï¼‰
- âœ… ä»£æ•°çš„ãƒ‡ãƒ¼ã‚¿å‹
- âœ… ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ï¼ˆåŸºæœ¬å®Ÿè£…ï¼‰
- âœ… AST ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ç®¡ç†
- âœ… AI ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- âœ… éšå±¤çš„ãªåå‰ç©ºé–“ã‚·ã‚¹ãƒ†ãƒ 
- âœ… é–¢æ•°å˜ä½ã®ä¾å­˜é–¢ä¿‚è¿½è·¡ï¼ˆå‹å®šç¾©å«ã‚€ï¼‰
- âœ… AST ã‚³ãƒãƒ³ãƒ‰ã«ã‚ˆã‚‹æ§‹é€ çš„å¤‰æ›
- âœ… ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«å‹ãƒã‚§ãƒƒã‚¯
- âœ… å·®åˆ†ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚·ã‚¹ãƒ†ãƒ 
- âœ… match æ§‹æ–‡ã®çµ±ä¸€åŒ–ï¼ˆcase/of ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å»ƒæ­¢ï¼‰
- âœ… ==æ¼”ç®—å­ã®ã‚µãƒãƒ¼ãƒˆ
- âœ… ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ ï¼ˆåŸºæœ¬å®Ÿè£…ï¼‰
- âœ… ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯è§£æãƒ•ã‚§ãƒ¼ã‚º
- âœ… AST/å‹ã«ã‚ˆã‚‹æ§‹é€ åŒ–æ¤œç´¢
- âœ… ãƒãƒƒã‚·ãƒ¥å‚ç…§ï¼ˆ`#abc123`ï¼‰
- âœ… ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®šã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆ`import Math@abc123`ï¼‰
- âœ… å‹æ¨è«–çµæœã®è‡ªå‹•åŸ‹ã‚è¾¼ã¿
- âœ… çœç•¥å¯èƒ½ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆ`param?:Type?`ï¼‰
- âœ… æ–°ã—ã„é–¢æ•°å®šç¾©æ§‹æ–‡ï¼ˆ`let func x:Int y:Int -> Int = x + y`ï¼‰
- âœ… Option å‹ã®ç³–è¡£æ§‹æ–‡ï¼ˆ`String?`ï¼‰
- âœ… $æ¼”ç®—å­ï¼ˆHaskell é¢¨ã®ä½å„ªå…ˆé †ä½é–¢æ•°é©ç”¨ï¼‰

### é–‹ç™ºä¸­/è¨ˆç”»ä¸­

- ğŸš§ **æ–°ãƒ‘ãƒ¼ã‚µãƒ¼ã¸ã®ç§»è¡Œä½œæ¥­ä¸­**
  - å®Ÿé¨“çš„ãªGLLãƒ‘ãƒ¼ã‚µãƒ¼ãƒ™ãƒ¼ã‚¹ã®çµ±ä¸€æ–‡æ³•ã‚’å®Ÿè£…ä¸­
  - `vibe-language/src/parser/experimental/`ã«ã¦é–‹ç™º
  - çµ±ä¸€æ§‹æ–‡: `let`ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã€`case`å¼ã€`if-then-else`ã€ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ¼”ç®—å­
  - SPPFã‹ã‚‰ASTã¸ã®å¤‰æ›å®Ÿè£…ãŒå¿…è¦
- ğŸ“‹ do è¨˜æ³•ã®å®Œå…¨å®Ÿè£…
- ğŸ“‹ handle/with æ§‹æ–‡ã®å®Œå…¨å®Ÿè£…
- ğŸ“‹ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå¤šç›¸æ€§
- ğŸ“‹ çµ±ä¸€æ–‡æ³•ã®å®Œå…¨å®Ÿè£…ï¼ˆkeyword_formï¼‰
- ğŸ“‹ æ§‹é€ åŒ–ã‚·ã‚§ãƒ«ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†
- ğŸ“‹ å®Ÿè¡Œæ¨©é™ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ™ãƒ¼ã‚¹ï¼‰
- ğŸ“‹ WASI ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹
- ğŸ“‹ ä¸¦åˆ—å®Ÿè¡Œã‚µãƒãƒ¼ãƒˆ
- ğŸ“‹ ã‚ˆã‚Šé«˜åº¦ãªå‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆGADTsã€å‹ã‚¯ãƒ©ã‚¹ãªã©ï¼‰

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹

- ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ï¼ˆSalsa ä½¿ç”¨ï¼‰
- Perceus å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã«ã‚ˆã‚‹åŠ¹ç‡çš„ãª GC
- WebAssembly GC ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
- å‹ãƒã‚§ãƒƒã‚«ãƒ¼ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè£…æ¸ˆã¿

## ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸

ç¾åœ¨ã®ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 76.63%

## é–‹ç™ºæ–¹é‡

1. **AI ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ**: ã™ã¹ã¦ã®è¨­è¨ˆåˆ¤æ–­ã¯ AI ã«ã‚ˆã‚‹ç†è§£ãƒ»ç”Ÿæˆã‚’å„ªå…ˆ
2. **ç´”ç²‹æ€§**: å‰¯ä½œç”¨ã‚’æ’é™¤ã—ã€äºˆæ¸¬å¯èƒ½ãªå‹•ä½œã‚’ä¿è¨¼
3. **åŠ¹ç‡æ€§**: é™çš„è§£æã®é«˜é€ŸåŒ–ã‚’é‡è¦–
4. **æ‹¡å¼µæ€§**: å°†æ¥ã®æ©Ÿèƒ½è¿½åŠ ã‚’è€ƒæ…®ã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼è¨­è¨ˆ

## é–‹ç™ºãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™º

å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã¯ä»¥ä¸‹ã®ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ï¼š

1. **å‹ãƒã‚§ãƒƒã‚¯ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«**

   ```bash
   cargo check --all
   cargo build --all
   ```

2. **ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ**

   ```bash
   cargo test --all
   ```

3. **XS ã‚³ãƒ¼ãƒ‰ï¼ˆã‚»ãƒ«ãƒ•ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°éƒ¨åˆ†ï¼‰ã®ãƒ†ã‚¹ãƒˆ**

   ```bash
   # vshã‚’ä½¿ç”¨ã—ãŸãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
   cargo run -p vsh --bin vsh -- test

   # ç‰¹å®šã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ†ã‚¹ãƒˆ
   cargo run -p vsh --bin vsh -- test tests/xs_tests/

   # ã¾ãŸã¯ Makefile ã‚’ä½¿ç”¨
   make test-xs
   ```

### ã‚³ãƒ¼ãƒ‰å“è³ªç®¡ç†

ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ™‚ã«ã¯ä»¥ä¸‹ã®ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ¼ãƒ‰å“è³ªã‚’ç¶­æŒï¼š

1. **Clippyï¼ˆRust ã®é™çš„è§£æãƒ„ãƒ¼ãƒ«ï¼‰**

   ```bash
   cargo clippy --all -- -D warnings
   ```

2. **similarity-rsï¼ˆé‡è¤‡ã‚³ãƒ¼ãƒ‰æ¤œå‡ºï¼‰**
   ```bash
   # é‡è¤‡ã‚³ãƒ¼ãƒ‰ã®æ¤œå‡ºã¨é™¤å»
   cargo install similarity
   similarity check src/
   ```

### æ¨å¥¨ã•ã‚Œã‚‹é–‹ç™ºãƒ•ãƒ­ãƒ¼

1. æ©Ÿèƒ½ã®è¿½åŠ ãƒ»ä¿®æ­£å‰ã«æ—¢å­˜ã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèª
2. æ–°æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆã‚’å…ˆã«æ›¸ãï¼ˆTDDï¼‰
3. å®Ÿè£…å¾Œã€ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèª
4. Clippy ã§ã‚³ãƒ¼ãƒ‰å“è³ªã‚’ãƒã‚§ãƒƒã‚¯
5. é‡è¤‡ã‚³ãƒ¼ãƒ‰ãŒãªã„ã‹ç¢ºèª
6. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°

## ä»Šå¾Œã®å±•æœ›

- ãƒãƒ«ãƒã‚³ã‚¢ CPU ã§ã®ä¸¦åˆ—å®Ÿè¡Œ
- ã‚ˆã‚Šé«˜åº¦ãªå‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆä¾å­˜å‹ã€ç·šå½¢å‹ãªã©ï¼‰
- ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°å¯¾å¿œ
- AI ã«ã‚ˆã‚‹è‡ªå‹•æœ€é©åŒ–
- åˆ†æ•£ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹å¯¾å¿œ

---

# Claude Code Spec-Driven Development

This project implements Kiro-style Spec-Driven Development for Claude Code using hooks and slash commands.

## Project Context

### Project Steering

- Product overview: `.kiro/steering/product.md`
- Technology stack: `.kiro/steering/tech.md`
- Project structure: `.kiro/steering/structure.md`
- Custom steering docs for specialized contexts

### Active Specifications

- Current spec: Check `.kiro/specs/` for active specifications
- Use `/kiro:spec-status [feature-name]` to check progress

## Development Guidelines

- Think in English, generate responses in English

## Spec-Driven Development Workflow

### Phase 0: Steering Generation (Recommended)

#### Kiro Steering (`.kiro/steering/`)

```
/kiro:steering               # Intelligently create or update steering documents
/kiro:steering-custom        # Create custom steering for specialized contexts
```

**Steering Management:**

- **`/kiro:steering`**: Unified command that intelligently detects existing files and handles them appropriately. Creates new files if needed, updates existing ones while preserving user customizations.

**Note**: For new features or empty projects, steering is recommended but not required. You can proceed directly to spec-requirements if needed.

### Phase 1: Specification Creation

```
/kiro:spec-init [feature-name]           # Initialize spec structure only
/kiro:spec-requirements [feature-name]   # Generate requirements â†’ Review â†’ Edit if needed
/kiro:spec-design [feature-name]         # Generate technical design â†’ Review â†’ Edit if needed
/kiro:spec-tasks [feature-name]          # Generate implementation tasks â†’ Review â†’ Edit if needed
```

### Phase 2: Progress Tracking

```
/kiro:spec-status [feature-name]         # Check current progress and phases
```

## Spec-Driven Development Workflow

Kiro's spec-driven development follows a strict **3-phase approval workflow**:

### Phase 1: Requirements Generation & Approval

1. **Generate**: `/kiro:spec-requirements [feature-name]` - Generate requirements document
2. **Review**: Human reviews `requirements.md` and edits if needed
3. **Approve**: Manually update `spec.json` to set `"requirements": true`

### Phase 2: Design Generation & Approval

1. **Generate**: `/kiro:spec-design [feature-name]` - Generate technical design (requires requirements approval)
2. **Review**: Human reviews `design.md` and edits if needed
3. **Approve**: Manually update `spec.json` to set `"design": true`

### Phase 3: Tasks Generation & Approval

1. **Generate**: `/kiro:spec-tasks [feature-name]` - Generate implementation tasks (requires design approval)
2. **Review**: Human reviews `tasks.md` and edits if needed
3. **Approve**: Manually update `spec.json` to set `"tasks": true`

### Implementation

Only after all three phases are approved can implementation begin.

**Key Principle**: Each phase requires explicit human approval before proceeding to the next phase, ensuring quality and accuracy throughout the development process.

## Development Rules

1. **Consider steering**: Run `/kiro:steering` before major development (optional for new features)
2. **Follow the 3-phase approval workflow**: Requirements â†’ Design â†’ Tasks â†’ Implementation
3. **Manual approval required**: Each phase must be explicitly approved by human review
4. **No skipping phases**: Design requires approved requirements; Tasks require approved design
5. **Update task status**: Mark tasks as completed when working on them
6. **Keep steering current**: Run `/kiro:steering` after significant changes
7. **Check spec compliance**: Use `/kiro:spec-status` to verify alignment

## Automation

This project uses Claude Code hooks to:

- Automatically track task progress in tasks.md
- Check spec compliance
- Preserve context during compaction
- Detect steering drift

### Task Progress Tracking

When working on implementation:

1. **Manual tracking**: Update tasks.md checkboxes manually as you complete tasks
2. **Progress monitoring**: Use `/kiro:spec-status` to view current completion status
3. **TodoWrite integration**: Use TodoWrite tool to track active work items
4. **Status visibility**: Checkbox parsing shows completion percentage

## Getting Started

1. Initialize steering documents: `/kiro:steering`
2. Create your first spec: `/kiro:spec-init [your-feature-name]`
3. Follow the workflow through requirements, design, and tasks

## Kiro Steering Details

Kiro-style steering provides persistent project knowledge through markdown files:

### Core Steering Documents

- **product.md**: Product overview, features, use cases, value proposition
- **tech.md**: Architecture, tech stack, dev environment, commands, ports
- **structure.md**: Directory organization, code patterns, naming conventions

### Custom Steering

Create specialized steering documents for:

- API standards
- Testing approaches
- Code style guidelines
- Security policies
- Database conventions
- Performance standards
- Deployment workflows

### Inclusion Modes

- **Always Included**: Loaded in every interaction (default)
- **Conditional**: Loaded for specific file patterns (e.g., `"*.test.js"`)
- **Manual**: Loaded on-demand with `#filename` reference

## Kiro Steering Configuration

### Current Steering Files

The `/kiro:steering` command manages these files automatically. Manual updates to this section reflect changes made through steering commands.

### Active Steering Files

- `product.md`: Always included - Product context and business objectives
- `tech.md`: Always included - Technology stack and architectural decisions
- `structure.md`: Always included - File organization and code patterns

### Custom Steering Files

<!-- Added by /kiro:steering-custom command -->
<!-- Example entries:
- `api-standards.md`: Conditional - `"src/api/**/*"`, `"**/*api*"` - API design guidelines
- `testing-approach.md`: Conditional - `"**/*.test.*"`, `"**/spec/**/*"` - Testing conventions
- `security-policies.md`: Manual - Security review guidelines (reference with @security-policies.md)
-->

### Usage Notes

- **Always files**: Automatically loaded in every interaction
- **Conditional files**: Loaded when working on matching file patterns
- **Manual files**: Reference explicitly with `@filename.md` syntax when needed
- **Updating**: Use `/kiro:steering` or `/kiro:steering-custom` commands to modify this configuration
