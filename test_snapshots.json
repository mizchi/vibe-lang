[
  {
    "file_path": "tests/xs_tests/integration/mixed_namespace.xs",
    "file_name": "mixed_namespace.xs",
    "input": "(String.concat \"Count: \" (Int.toString (Int.add 40 2)))",
    "output": {
      "Ok": "\"Count: 42\" : t7\n  [64d9d47b]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/integration/string_int_ops2.xs",
    "file_name": "string_int_ops2.xs",
    "input": "(let num-str \"100\" in (let num (string-to-int num-str) in (let doubled (+ num num) in (int-to-string doubled))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/integration/string_int_ops1.xs",
    "file_name": "string_int_ops1.xs",
    "input": "(let count 42 in (let message (str-concat \"The answer is: \" (int-to-string count)) in message))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/module/test_import_syntax.xs",
    "file_name": "test_import_syntax.xs",
    "input": "\n(import (Math add sub))\n",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/module/test_module_syntax.xs",
    "file_name": "test_module_syntax.xs",
    "input": "\n(module TestModule\n  (export foo bar)\n  (define foo 42)\n  (define bar (fn (x) (* x 2))))\n",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/records/test_records.xs",
    "file_name": "test_records.xs",
    "input": "; Test record (object literal) features\n\n; Helper function\n(let assertEqual (fn (actual expected testName)\n  (if (= actual expected)\n      true\n      (error (strConcat testName \" failed\")))))\n\n; Test basic record creation and field access\n(let person { name: \"Alice\", age: 30 })\n(assertEqual person.name \"Alice\" \"record field access - name\")\n(assertEqual person.age 30 \"record field access - age\")\n\n; Test nested records\n(let company {\n  name: \"TechCorp\",\n  address: { city: \"Tokyo\", zip: \"100-0001\" }\n})\n(assertEqual company.name \"TechCorp\" \"nested record - company name\")\n(assertEqual company.address.city \"Tokyo\" \"nested record field access\")\n\n; Test record as function parameter\n(let getAge (fn (p) p.age))\n(assertEqual (getAge { name: \"Bob\", age: 25 }) 25 \"record as function parameter\")\n\n; Test function returning record\n(let makePoint (fn (x y) { x: x, y: y }))\n(let point (makePoint 10 20))\n(assertEqual point.x 10 \"function returning record - x\")\n(assertEqual point.y 20 \"function returning record - y\")\n\n; Test record with different field types\n(let mixed {\n  count: 42,\n  label: \"answer\",\n  valid: true\n})\n(assertEqual mixed.count 42 \"mixed types - int\")\n(assertEqual mixed.label \"answer\" \"mixed types - string\")\n(assertEqual mixed.valid true \"mixed types - bool\")\n\n; Test functional update pattern\n(let original { x: 1, y: 2 })\n(let updated { x: original.x, y: 3 })\n(assertEqual updated.x 1 \"functional update - preserved field\")\n(assertEqual updated.y 3 \"functional update - new value\")\n\n; Test record equality (structural)\n(let p1 { x: 10, y: 20 })\n(let p2 { x: 10, y: 20 })\n(let p3 { x: 10, y: 30 })\n; Note: record equality may not be implemented yet\n; This would require deep structural comparison\n\n\"All record tests passed\"",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/test-framework/working-test.xs",
    "file_name": "working-test.xs",
    "input": "; Working test framework example  \n\n; Run direct tests\n(let t1 (if (= (+ 1 1) 2)\n            (print \"PASS: 1 + 1 = 2\")\n            (print \"FAIL: 1 + 1 = 2\")) in\n            \n(let t2 (if (= (* 2 3) 6)\n            (print \"PASS: 2 * 3 = 6\")\n            (print \"FAIL: 2 * 3 = 6\")) in\n            \n(let t3 (if (str-eq (str-concat \"a\" \"b\") \"ab\")\n            (print \"PASS: str-concat works\")\n            (print \"FAIL: str-concat works\")) in\n            \n(let t4 (if (= (car (list 1 2 3)) 1)\n            (print \"PASS: car works\")\n            (print \"FAIL: car works\")) in\n            \n(let t5 (if (= (car (cdr (list 1 2 3))) 2)\n            (print \"PASS: cdr works\")\n            (print \"FAIL: cdr works\")) in\n            \n(let t6 (if (null? (list))\n            (print \"PASS: null? works\")\n            (print \"FAIL: null? works\")) in\n            \n(let t7 (if (= 1 2)\n            (print \"PASS: This should fail\")\n            (print \"FAIL: This should fail\")) in\n\n(print \"All tests completed!\")))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/language-features/list-operations-test.xs",
    "file_name": "list-operations-test.xs",
    "input": ";; Comprehensive test for list operations\n\n;; Test car\n(let test-car-1 (= (car (list 1 2 3)) 1) in\n(let dummy1 (print (if test-car-1 \"✓ car [1,2,3] = 1\" \"✗ car [1,2,3] = 1\")) in\n\n;; Test cdr\n(let test-cdr-1 (let result (cdr (list 1 2 3)) in\n                 (if (null? result)\n                     false\n                     (= (car result) 2))) in\n(let dummy2 (print (if test-cdr-1 \"✓ cdr [1,2,3] starts with 2\" \"✗ cdr [1,2,3] starts with 2\")) in\n\n;; Test null?\n(let test-null-1 (null? (list)) in\n(let test-null-2 (if (null? (list 1)) false true) in\n(let dummy3 (print (if test-null-1 \"✓ null? [] = true\" \"✗ null? [] = true\")) in\n(let dummy4 (print (if test-null-2 \"✓ null? [1] = false\" \"✗ null? [1] = false\")) in\n\n;; Test combination\n(let test-combo (= (car (cdr (list 1 2 3))) 2) in\n(let dummy5 (print (if test-combo \"✓ car (cdr [1,2,3]) = 2\" \"✗ car (cdr [1,2,3]) = 2\")) in\n\n;; Final result\n(let all-passed (if test-car-1 \n                    (if test-cdr-1 \n                        (if test-null-1 \n                            (if test-null-2 test-combo false)\n                            false)\n                        false)\n                    false) in\n(if all-passed\n    (print \"\\nAll tests passed!\")\n    (print \"\\nSome tests failed!\"))))))))))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/language-features/rec-as-let-test.xs",
    "file_name": "rec-as-let-test.xs",
    "input": ";; Test rec with let binding\n\n(let factorial (rec factorial (n)\n  (if (= n 0)\n      1\n      (* n (factorial (- n 1))))) in\n\n(print (factorial 5)))",
    "output": {
      "Ok": "120 : Int\n  [d5ac0994]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/language-features/pattern-match-rest-test.xs",
    "file_name": "pattern-match-rest-test.xs",
    "input": ";; Test rest pattern matching\n\n;; Helper function to sum a list\n(let sum (rec sum (lst)\n  (match lst\n    ((list) 0)\n    ((list x ...rest) (+ x (sum rest))))) in\n\n;; Helper function to get first n elements\n(let take-n (rec take-n (n lst)\n  (match (list n lst)\n    ((list 0 _) (list))\n    ((list _ (list)) (list))\n    ((list n (list x ...rest)) \n      (cons x (take-n (- n 1) rest))))) in\n\n;; Test empty list pattern\n(let test1 (match (list)\n  ((list) \"empty\")\n  ((list ...rest) \"has rest\")) in\n\n;; Test single element with rest\n(let test2 (match (list 1 2 3 4 5)\n  ((list x ...rest) (list x rest))) in\n\n;; Test multiple fixed elements with rest\n(let test3 (match (list 1 2 3 4 5)\n  ((list a b ...rest) (list a b rest))) in\n\n;; Test sum function\n(let test4 (sum (list 1 2 3 4 5)) in\n\n;; Test take-n function\n(let test5 (take-n 3 (list 1 2 3 4 5)) in\n\n;; Print results\n(let dummy1 (print \"Test 1 (empty list):\") in\n(let dummy2 (print test1) in\n(let dummy3 (print \"\\nTest 2 (x ...rest with [1,2,3,4,5]):\") in\n(let dummy4 (print test2) in\n(let dummy5 (print \"\\nTest 3 (a b ...rest with [1,2,3,4,5]):\") in\n(let dummy6 (print test3) in\n(let dummy7 (print \"\\nTest 4 (sum [1,2,3,4,5]):\") in\n(let dummy8 (print test4) in\n(let dummy9 (print \"\\nTest 5 (take-n 3 [1,2,3,4,5]):\") in\n(let dummy10 (print test5) in\n\n(print \"\\nRest pattern tests completed!\"))))))))))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/io/print_test.xs",
    "file_name": "print_test.xs",
    "input": "(print \"hello\")",
    "output": {
      "Ok": "\"hello\" : String\n  [a3088e93]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/io/test_io_print.xs",
    "file_name": "test_io_print.xs",
    "input": "(IO.print \"Hello from namespace!\")",
    "output": {
      "Ok": "\"Hello from namespace!\" : t1\n  [b25ade45]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/io/print_namespace.xs",
    "file_name": "print_namespace.xs",
    "input": "(IO.print \"Hello from namespace!\")",
    "output": {
      "Ok": "\"Hello from namespace!\" : t1\n  [b25ade45]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/pattern-matching/test_list_patterns.xs",
    "file_name": "test_list_patterns.xs",
    "input": "; Test list pattern matching features\n\n; Helper function to check test results\n(let assertEqual (fn (actual expected testName)\n  (if (= actual expected)\n      true\n      (error (strConcat testName \" failed\")))))\n\n; Test empty list pattern\n(assertEqual\n  (match (list)\n    ((list) \"empty\")\n    (_ \"not empty\"))\n  \"empty\"\n  \"empty list pattern\")\n\n; Test single element pattern\n(assertEqual\n  (match (list 42)\n    ((list x) x)\n    (_ 0))\n  42\n  \"single element pattern\")\n\n; Test head and tail pattern\n(assertEqual\n  (match (list 1 2 3 4 5)\n    ((list h ... t) h)\n    (_ 0))\n  1\n  \"head extraction with ... pattern\")\n\n; Test tail extraction\n(assertEqual\n  (match (list 1 2 3)\n    ((list h ... t) (match t\n                       ((list a b) (+ a b))\n                       (_ 0)))\n    (_ 0))\n  5  ; 2 + 3\n  \"tail extraction\")\n\n; Test pattern with fixed prefix\n(assertEqual\n  (match (list 10 20 30 40 50)\n    ((list a b c ... rest) (+ a (+ b c)))\n    (_ 0))\n  60  ; 10 + 20 + 30\n  \"fixed prefix pattern\")\n\n; Test literal in list pattern\n(assertEqual\n  (match (list 1 2 3)\n    ((list 1 x 3) x)\n    (_ 0))\n  2\n  \"literal in list pattern\")\n\n; Test nested list patterns\n(assertEqual\n  (match (list (list 1 2) (list 3 4))\n    ((list (list a b) (list c d)) (+ a (+ b (+ c d))))\n    (_ 0))\n  10  ; 1 + 2 + 3 + 4\n  \"nested list patterns\")\n\n; Implement length function using pattern matching\n(let length (rec len (lst)\n  (match lst\n    ((list) 0)\n    ((list _ ... t) (+ 1 (len t))))))\n\n(assertEqual (length (list 1 2 3 4 5)) 5 \"length function\")\n\n; Implement sum function using pattern matching\n(let sum (rec sum (lst)\n  (match lst\n    ((list) 0)\n    ((list h ... t) (+ h (sum t))))))\n\n(assertEqual (sum (list 1 2 3 4 5)) 15 \"sum function\")\n\n; Test empty tail\n(assertEqual\n  (match (list 42)\n    ((list h ... t) (match t\n                       ((list) \"empty tail\")\n                       (_ \"has elements\")))\n    (_ \"no match\"))\n  \"empty tail\"\n  \"single element has empty tail\")\n\n\"All list pattern tests passed\"",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/to_int_err2.xs",
    "file_name": "to_int_err2.xs",
    "input": "(string-to-int \"\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_to_int_err2.xs",
    "file_name": "test_string_to_int_err2.xs",
    "input": "(string-to-int \"\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/to_int_neg.xs",
    "file_name": "to_int_neg.xs",
    "input": "(string-to-int \"-456\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_to_int_err1.xs",
    "file_name": "test_string_to_int_err1.xs",
    "input": "(string-to-int \"not a number\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/length_empty.xs",
    "file_name": "length_empty.xs",
    "input": "(string-length \"\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/to_int.xs",
    "file_name": "to_int.xs",
    "input": "(string-to-int \"123\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_concat.xs",
    "file_name": "test_string_concat.xs",
    "input": "(String.concat \"Hello, \" \"World!\")",
    "output": {
      "Ok": "\"Hello, World!\" : t2\n  [73e665ba]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_length_empty.xs",
    "file_name": "test_string_length_empty.xs",
    "input": "(string-length \"\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_fromint.xs",
    "file_name": "test_string_fromint.xs",
    "input": "(String.fromInt 123)",
    "output": {
      "Ok": "\"123\" : t1\n  [1a36cd0f]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/string_ops_test.xs",
    "file_name": "string_ops_test.xs",
    "input": "; String operations tests\n; expect: true\n\n(let test1 (str-eq (str-concat \"Hello, \" \"World!\") \"Hello, World!\") in\n  (let test2 (= (string-length \"hello\") 5) in\n    (let test3 (= (string-length \"\") 0) in\n      (let test4 (str-eq (int-to-string 42) \"42\") in\n        (let test5 (str-eq (int-to-string -123) \"-123\") in\n          (let test6 (= (string-to-int \"123\") 123) in\n            (let test7 (str-eq \"test\" \"test\") in\n              (let test8 (if (str-eq \"hello\" \"world\") false true) in\n                (let s1 (str-concat \"a\" \"b\") in\n                  (let s2 (str-concat s1 \"c\") in\n                    (let test9 (str-eq s2 \"abc\") in\n                      (let test10 (str-eq \n                                    (str-concat (str-concat \"one\" \"two\") \"three\")\n                                    \"onetwothree\") in\n                        (if test1\n                            (if test2\n                                (if test3\n                                    (if test4\n                                        (if test5\n                                            (if test6\n                                                (if test7\n                                                    (if test8\n                                                        (if test9\n                                                            test10\n                                                            false)\n                                                        false)\n                                                    false)\n                                                false)\n                                            false)\n                                        false)\n                                    false)\n                                false)\n                            false)))))))))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_to_int_neg.xs",
    "file_name": "test_string_to_int_neg.xs",
    "input": "(string-to-int \"-456\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/string_concat_test.xs",
    "file_name": "string_concat_test.xs",
    "input": "; Test str-concat\n(print (str-concat \"Hello, \" \"World!\"))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_ops_combined1.xs",
    "file_name": "test_string_ops_combined1.xs",
    "input": "(let count 42 in (let message (str-concat \"The answer is: \" (int-to-string count)) in message))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_length.xs",
    "file_name": "test_string_length.xs",
    "input": "(string-length \"Hello\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_ops_combined2.xs",
    "file_name": "test_string_ops_combined2.xs",
    "input": "(let num-str \"100\" in (let num (string-to-int num-str) in (let doubled (+ num num) in (int-to-string doubled))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_to_int.xs",
    "file_name": "test_string_to_int.xs",
    "input": "(string-to-int \"123\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/concat_namespace.xs",
    "file_name": "concat_namespace.xs",
    "input": "(String.concat \"Hello, \" \"World!\")",
    "output": {
      "Ok": "\"Hello, World!\" : t2\n  [73e665ba]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/length_long.xs",
    "file_name": "length_long.xs",
    "input": "(string-length \"Hello, World!\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/to_int_err1.xs",
    "file_name": "to_int_err1.xs",
    "input": "(string-to-int \"not a number\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/from_int.xs",
    "file_name": "from_int.xs",
    "input": "(String.fromInt 123)",
    "output": {
      "Ok": "\"123\" : t1\n  [1a36cd0f]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_to_int_zero.xs",
    "file_name": "test_string_to_int_zero.xs",
    "input": "(string-to-int \"0\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/to_int_zero.xs",
    "file_name": "to_int_zero.xs",
    "input": "(string-to-int \"0\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_str_concat.xs",
    "file_name": "test_str_concat.xs",
    "input": "(str-concat \"Hello, \" \"World!\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/test_string_length_long.xs",
    "file_name": "test_string_length_long.xs",
    "input": "(string-length \"Hello, World!\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/string/length.xs",
    "file_name": "length.xs",
    "input": "(string-length \"Hello\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/test_int_to_string_neg.xs",
    "file_name": "test_int_to_string_neg.xs",
    "input": "(int-to-string -123)",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/add.xs",
    "file_name": "add.xs",
    "input": "(Int.add 10 20)",
    "output": {
      "Ok": "30 : t2\n  [b80462be]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/test_int_to_string.xs",
    "file_name": "test_int_to_string.xs",
    "input": "(int-to-string 42)",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/test_int_eq.xs",
    "file_name": "test_int_eq.xs",
    "input": "(Int.eq 5 5)",
    "output": {
      "Ok": "true : t2\n  [8960e0e2]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/eq.xs",
    "file_name": "eq.xs",
    "input": "(Int.eq 5 5)",
    "output": {
      "Ok": "true : t2\n  [8960e0e2]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/to_string_zero.xs",
    "file_name": "to_string_zero.xs",
    "input": "(int-to-string 0)",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/to_string_neg.xs",
    "file_name": "to_string_neg.xs",
    "input": "(int-to-string -123)",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/to_string_builtin.xs",
    "file_name": "to_string_builtin.xs",
    "input": "(int-to-string 42)",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/test_int_to_string_zero.xs",
    "file_name": "test_int_to_string_zero.xs",
    "input": "(int-to-string 0)",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/test_int_add.xs",
    "file_name": "test_int_add.xs",
    "input": "(Int.add 10 20)",
    "output": {
      "Ok": "30 : t2\n  [b80462be]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/test_int_tostring.xs",
    "file_name": "test_int_tostring.xs",
    "input": "(Int.toString 42)",
    "output": {
      "Ok": "\"42\" : t1\n  [8d15fdce]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/int/tostring_namespace.xs",
    "file_name": "tostring_namespace.xs",
    "input": "(Int.toString 42)",
    "output": {
      "Ok": "\"42\" : t1\n  [8d15fdce]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/lambda/lambda_test.xs",
    "file_name": "lambda_test.xs",
    "input": "; Lambda expression tests\n; expect: true\n\n(let test1 (= ((fn (x) x) 10) 10) in\n  (let const42 (fn (x) 42) in\n    (let test2 (= (const42 99) 42) in\n      (let test3 (= ((fn (x y) (+ x y)) 3 4) 7) in\n        (let f (fn (x) (fn (y) (+ x y))) in\n          (let add5 (f 5) in\n            (let test4 (= (add5 3) 8) in\n              (let apply (fn (f x) (f x)) in\n                (let double (fn (x) (* x 2)) in\n                  (let test5 (= (apply double 21) 42) in\n                    (let curry-add (fn (x) (fn (y) (+ x y))) in\n                      (let add10 (curry-add 10) in\n                        (let test6 (= (add10 32) 42) in\n                          (let make-adder (fn (n) (fn (x) (+ x n))) in\n                            (let add3 (make-adder 3) in\n                              (let test7 (= (add3 7) 10) in\n                                (if test1\n                                    (if test2\n                                        (if test3\n                                            (if test4\n                                                (if test5\n                                                    (if test6\n                                                        test7\n                                                        false)\n                                                    false)\n                                                false)\n                                            false)\n                                        false)\n                                    false))))))))))))))))))",
    "output": {
      "Ok": "true : Bool\n  [a0413f7d]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/list/car_cdr_test.xs",
    "file_name": "car_cdr_test.xs",
    "input": ";; Test car, cdr, null? functions\n;; expect: true\n\n;; Helper functions\n(let not (fn (x) (if x false true)) in\n(let and (fn (a b) (if a b false)) in\n\n;; Test car (head)\n(let lst1 (list 1 2 3) in\n(let head1 (car lst1) in\n\n;; Test cdr (tail)\n(let tail1 (cdr lst1) in\n\n;; Test null?\n(let empty (list) in\n(let non-empty (list 1) in\n\n;; Check results\n(let test1 (= head1 1) in\n(let test2 (= (car tail1) 2) in\n(let test3 (null? empty) in\n(let test4 (not (null? non-empty)) in\n\n;; All tests must pass\n(and test1 (and test2 (and test3 test4)))))))))))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/list/test_list_cons.xs",
    "file_name": "test_list_cons.xs",
    "input": "(List.cons 1 (cons 2 (cons 3 (list))))",
    "output": {
      "Ok": "(list 1 2 3) : t7\n  [50557862]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/list/cons.xs",
    "file_name": "cons.xs",
    "input": "(List.cons 1 (cons 2 (cons 3 (list))))",
    "output": {
      "Ok": "(list 1 2 3) : t7\n  [50557862]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/pipeline/pipeline_test.xs",
    "file_name": "pipeline_test.xs",
    "input": "; Pipeline operator tests  \n; expect: true\n\n(let inc (fn (x) (+ x 1)) in\n  (let double (fn (x) (* x 2)) in\n    (let add3 (fn (x) (+ x 3)) in\n      \n      ; Test manual pipeline equivalents\n      (let test1 (= (double (inc 5)) 12) in\n        (let test2 (= (double (inc (add3 10))) 28) in\n          (let test3 (str-eq (int-to-string (inc (string-to-int \"42\"))) \"43\") in\n            (let test4 (str-eq \n                         (str-concat \"Number: \" (int-to-string (inc (string-to-int \"42\"))))\n                         \"Number: 43\") in\n              \n              ; All tests must pass\n              (if test1\n                  (if test2\n                      (if test3\n                          test4\n                          false)\n                      false)\n                  false))))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/builtin/str_concat.xs",
    "file_name": "str_concat.xs",
    "input": "(str-concat \"Hello, \" \"World!\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/builtin/plus.xs",
    "file_name": "plus.xs",
    "input": "(+ 10 20)",
    "output": {
      "Ok": "30 : Int\n  [a921e268]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/namespace/test_backward_strconcat.xs",
    "file_name": "test_backward_strconcat.xs",
    "input": "(str-concat \"Hello, \" \"World!\")",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/namespace/test_mixed_namespace.xs",
    "file_name": "test_mixed_namespace.xs",
    "input": "(String.concat \"Count: \" (Int.toString (Int.add 40 2)))",
    "output": {
      "Ok": "\"Count: 42\" : t7\n  [64d9d47b]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/namespace/namespace_test.xs",
    "file_name": "namespace_test.xs",
    "input": "; Test builtin module namespaces\n\n; Test Int module\n(IO.print (Int.toString 42))\n(IO.print (Int.add 10 20))\n\n; Test String module  \n(IO.print (String.concat \"Hello, \" \"World!\"))\n(IO.print (String.length \"Hello\"))\n(IO.print (String.fromInt 123))\n\n; Test mixed usage\n(IO.print (String.concat \"Answer: \" (Int.toString 42)))",
    "output": {
      "Ok": "\"42\" : t3\n  [78e983a7]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/namespace/test_backward_plus.xs",
    "file_name": "test_backward_plus.xs",
    "input": "(+ 10 20)",
    "output": {
      "Ok": "30 : Int\n  [a921e268]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/basic/basic_tests.xs",
    "file_name": "basic_tests.xs",
    "input": "; Basic test suite\n; expect: true\n\n; Test arithmetic operations\n(let test1 (= (+ 2 2) 4) in\n  (let test2 (= (* 3 4) 12) in\n    (let test3 (= (- 10 5) 5) in\n      (let test4 (= (/ 20 4) 5) in\n        \n        ; Test string operations\n        (let test5 (str-eq (str-concat \"Hello, \" \"World!\") \"Hello, World!\") in\n          (let test6 (= (string-length \"hello\") 5) in\n            (let test7 (str-eq (int-to-string 42) \"42\") in\n              (let test8 (= (string-to-int \"123\") 123) in\n                \n                ; Test lambda expressions\n                (let test9 (= ((fn (x) x) 10) 10) in\n                  (let test10 (= ((fn (x y) (+ x y)) 3 4) 7) in\n                    \n                    ; Test conditionals\n                    (let test11 (= (if true 1 2) 1) in\n                      (let test12 (= (if false 1 2) 2) in\n                        \n                        ; Test let bindings\n                        (let x 10 in\n                          (let y (+ x 5) in\n                            (let test13 (= y 15) in\n                              \n                              ; Test lists\n                              (let lst (list 1 2 3) in\n                                (let test14 (match lst\n                                              ((list h t) (= h 1))\n                                              (_ false)) in\n                                \n                                  ; Test partial application\n                                  (let add (fn (x y) (+ x y)) in\n                                    (let add5 (add 5) in\n                                      (let test15 (= (add5 3) 8) in\n                                      \n                                        ; All tests must pass\n                                        (if test1\n                                            (if test2\n                                                (if test3\n                                                    (if test4\n                                                        (if test5\n                                                            (if test6\n                                                                (if test7\n                                                                    (if test8\n                                                                        (if test9\n                                                                            (if test10\n                                                                                (if test11\n                                                                                    (if test12\n                                                                                        (if test13\n                                                                                            (if test14\n                                                                                                test15\n                                                                                                false)\n                                                                                            false)\n                                                                                        false)\n                                                                                    false)\n                                                                                false)\n                                                                            false)\n                                                                        false)\n                                                                    false)\n                                                                false)\n                                                            false)\n                                                        false)\n                                                    false)\n                                                false)\n                                            false))))))))))))))))))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/basic/failure_test.xs",
    "file_name": "failure_test.xs",
    "input": "; Test that demonstrates failure cases\n; expect: false\n\n; This file intentionally contains failing tests\n; Test 1: arithmetic failure\n(let test1 (= 1 2) in\n\n; Test 2: string comparison failure\n(let test2 (str-eq \"hello\" \"world\") in\n\n; Test 3: false condition\n(let test3 false in\n\n; Test 4: wrong list match\n(let test4 (match (list 1 2 3)\n             ((list 3 (list 2 (list 1 (list)))) true)\n             (_ false)) in\n\n; At least one test should fail\n(if test1\n    (if test2\n        (if test3\n            test4\n            false)\n        false)\n    false)))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": true
  },
  {
    "file_path": "tests/xs_tests/result/result_test.xs",
    "file_name": "result_test.xs",
    "input": ";; Direct test execution\n\n(let not (fn (x) (if x false true)) in\n(let and (fn (a b) (if a b false)) in\n(let dummy1 (print \"\\n=== Basic Tests ===\") in\n\n;; Test 1\n(let test1 (= (+ 1 1) 2) in\n(let dummy2 (print (if test1 \"✓ 1 + 1 = 2\" \"✗ 1 + 1 = 2\")) in\n\n;; Test 2\n(let test2 (str-eq \"hello\" \"hello\") in\n(let dummy3 (print (if test2 \"✓ string equality\" \"✗ string equality\")) in\n\n;; Test 3\n(let test3 (and true true) in\n(let dummy4 (print (if test3 \"✓ and true true\" \"✗ and true true\")) in\n\n;; Test 4\n(let test4 (not false) in\n(let dummy5 (print (if test4 \"✓ not false\" \"✗ not false\")) in\n\n;; Test 5\n(let test5 (str-eq (str-concat \"hello\" \" world\") \"hello world\") in\n(let dummy6 (print (if test5 \"✓ string concat\" \"✗ string concat\")) in\n\n;; Summary\n(let passed (+ (if test1 1 0) \n              (+ (if test2 1 0) \n                 (+ (if test3 1 0) \n                    (+ (if test4 1 0) \n                       (if test5 1 0))))) in\n(let failed (- 5 passed) in\n(let dummy7 (print (str-concat \"\\nPassed: \" (int-to-string passed))) in\n(let dummy8 (print (str-concat \"Failed: \" (int-to-string failed))) in\n(if (= failed 0)\n    (print \"\\nAll tests passed! ✨\")\n    (print \"\\nSome tests failed! ❌\"))))))))))))))))))))",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/pattern/test_pattern.xs",
    "file_name": "test_pattern.xs",
    "input": "(match (list 1 2) ((list) 0) ((list x _) x))\n",
    "output": {
      "Ok": "1 : Int\n  [f94dca74]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/pattern/test_pattern2.xs",
    "file_name": "test_pattern2.xs",
    "input": "(match (list 1 2) ((list) 0) ((list x y) x))\n",
    "output": {
      "Ok": "1 : Int\n  [a4ad16a8]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_simple_let_in.xs",
    "file_name": "test_simple_let_in.xs",
    "input": "(let x 10 in (+ x 5))",
    "output": {
      "Ok": "15 : Int\n  [829838ba]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_match_let_in.xs",
    "file_name": "test_match_let_in.xs",
    "input": "\n(match (list 1 2 3)\n  ((list) 0)\n  ((list x xs)\n    (let head_squared (* x x) in\n      head_squared)))\n",
    "output": {
      "Ok": "1 : Int\n  [a37f6ed5]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_rec_multiple_let_in.xs",
    "file_name": "test_rec_multiple_let_in.xs",
    "input": "\n((rec sum_squares (n)\n  (let is_zero (= n 0) in\n    (if is_zero\n        0\n        (let square (* n n) in\n          (+ square (sum_squares (- n 1)))))))\n 5)\n",
    "output": {
      "Ok": "55 : Int\n  [5a10bce0]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_rec_let_in.xs",
    "file_name": "test_rec_let_in.xs",
    "input": "((rec factorial (n)\n  (let is_zero (= n 0) in\n    (if is_zero\n        1\n        (* n (factorial (- n 1))))))\n 5)",
    "output": {
      "Ok": "120 : Int\n  [05a75015]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_nested_let_in.xs",
    "file_name": "test_nested_let_in.xs",
    "input": "\n(let x 10 in\n  (let y 20 in\n    (+ x y)))\n",
    "output": {
      "Ok": "30 : Int\n  [4adf99e7]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_let_in_poly.xs",
    "file_name": "test_let_in_poly.xs",
    "input": "\n(let id (fn (x) x) in\n  (let int_result (id 42) in\n    (let bool_result (id true) in\n      int_result)))\n",
    "output": {
      "Ok": "42 : Int\n  [4d1289cc]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_let_in_type_ann.xs",
    "file_name": "test_let_in_type_ann.xs",
    "input": "(let x : Int 42 in (* x 2))",
    "output": {
      "Ok": "84 : Int\n  [6b11840a]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_let_in_scope_error.xs",
    "file_name": "test_let_in_scope_error.xs",
    "input": "\n(let x 10 in y)\n",
    "output": {
      "Err": "Type inference failed"
    },
    "is_error_test": true
  },
  {
    "file_path": "tests/xs_tests/let_in/test_higher_order_let_in.xs",
    "file_name": "test_higher_order_let_in.xs",
    "input": "\n(let apply_twice (fn (f x)\n  (let once (f x) in\n    (f once)))\nin\n  (apply_twice (fn (n) (* n 2)) 3))\n",
    "output": {
      "Ok": "12 : Int\n  [b7463840]"
    },
    "is_error_test": false
  },
  {
    "file_path": "tests/xs_tests/let_in/test_lambda_let_in.xs",
    "file_name": "test_lambda_let_in.xs",
    "input": "\n((fn (x)\n  (let doubled (* x 2) in\n    (+ doubled 10)))\n 5)\n",
    "output": {
      "Ok": "20 : Int\n  [ae245ee1]"
    },
    "is_error_test": false
  }
]