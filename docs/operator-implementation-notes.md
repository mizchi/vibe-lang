# 演算子実装の技術的詳細

## パイプライン演算子 |>

### 現在の実装
```rust
// AST
Pipeline {
    expr: Box<Expr>,    // 左側の値
    func: Box<Expr>,    // 右側の関数
    span: Span,
}

// 評価時の変換
x |> f  →  f x
x |> f y  →  f y x  // 部分適用された関数の場合
```

### 特徴
- 専用のASTノード
- 左側の値を右側の関数の最後の引数として適用
- 段階的な変換を視覚的に表現

## ドル演算子 $

### 現在の実装
```rust
// AST: 通常のApplyノードを使用
Apply {
    func: Box<Expr>,    // 関数
    args: Vec<Expr>,    // 引数
    span: Span,
}

// パース時の処理
f $ x  →  Apply { func: f, args: [x] }
```

### 特徴
- 特別なASTノードは不要
- 単純に優先順位が最低の関数適用
- 右結合により、右側全体を引数として扱う

## 実装上の違い

### 1. AST表現
- `|>`: 専用の`Pipeline`ノード（意図が明確）
- `$`: 通常の`Apply`ノード（シンプル）

### 2. 型チェック
- `|>`: `f: a -> b`と`x: a`から`b`を導出
- `$`: 通常の関数適用と同じ

### 3. 最適化の可能性
- `|>`: パイプラインの最適化が可能
  - 中間値の除去
  - ストリーム処理への変換
- `$`: 通常の関数適用として最適化

### 4. エラーメッセージ
```vibe
# |> のエラー
x |> notAFunction
# Error: Expected a function in pipeline, got Int

# $ のエラー  
notAFunction $ x
# Error: Expected a function, got Int
```

## 将来の拡張可能性

### パイプライン演算子の拡張案
```vibe
# タップ演算子（値を通過させながら副作用）
x |> tap println |> double

# 条件付きパイプライン
x |> when positive double

# エラーハンドリング
x |> try parse |> default 0
```

### ドル演算子の拡張案
```vibe
# 複数引数対応？
f $$ x y  # f x y

# 逆適用？
x $> f  # f x （|>と同じ）
```

## パフォーマンスの観点

### コンパイル時
- `|>`: Pipeline→Applyへの変換が必要
- `$`: 変換不要（既にApply）

### 実行時
- 両方とも最終的には同じ関数適用
- パフォーマンス差はない

## 推奨事項

### 使い分けの実装ガイド
1. `|>` は変換の意図を明示するため、専用ノードを維持
2. `$` は構文糖として最小限の実装
3. 両方とも最終的には同じ関数適用にコンパイル

### 最適化の優先順位
1. まず正しい動作の保証
2. パイプラインの連鎖最適化
3. 将来的にストリーム処理への変換