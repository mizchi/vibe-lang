アーキテクチャ全体像

フロントエンド：字句解析 → 構文解析 → AST 生成

型チェック：変更箇所のみ再計算できるクエリベース（Salsa）または Datalog ベースでインクリメンタルに実行

中間表現（IR）：複数レイヤーで設計し、差分最適化やコンパイルキャッシュに対応

最適化パス：定数畳み込み、デッドコード除去、ループ変換などを中レベル IR 上で差分実行

バックエンド：低レベル IR→WebAssembly（またはネイティブ）へのコード生成

インクリメンタル型チェック／部分コンパイル

クエリフレームワーク（Salsa）

依存グラフを自動管理し、変更伝播だけ再実行

永続キャッシュで複数セッション間の再利用も可能

Datalog ベース

型推論ルールを増分ソルバで実装

Unison／Nix 風差分管理

各定義を内容ハッシュで管理し、同ハッシュなら再利用

REPL と nushell 連携

ソース → 高レベル IR → 型チェック → 軽量インタプリタ or バイトコード

変更定義のみ即時検査・評価、既存定義はキャッシュ再利用

「ワンライナー」を高レベル IR に追加 → 内容アドレス DB に蓄積 →nushell 評価

多層 IR 設計

高レベル IR（Typed AST）

ソース構文に近く型注釈付き

A‑Normal Form で平坦化、定義単位にハッシュ ID

REPL 向け軽量インタプリタ実行基盤

中レベル IR（Typed SSA/Dataflow Graph）

SSA 形式で依存と寿命を明示

副作用マーカー付きノードを差分最適化

低レベル IR（Wasm バイトコードなど）

スタック／レジスタモデル

JIT／AOT 両対応

実行時オーバーヘッド軽減策

JIT プロファイル駆動：ホットパスのみ中レベル IR までコンパイル

遅延最適化：REPL は最小パス、AOT モードで重い最適化

共有ランタイムライブラリ化：GC や I/O をネイティブ化して呼び出しコスト削減

WebAssembly ランタイムとの親和性

Wasm を低レベル IR としてそのまま利用

instantiateStreaming/compileStreaming でストリーミング＆インクリメンタルコンパイル

Component Model でモジュール単位の動的リンク＆型安全インターフェース

Wasmtime 等のランタイムで差分 JIT キャッシュを活用
