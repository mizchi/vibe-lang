# Rustパーサージェネレーター比較：gll-pg vs wagon-gll vs rustemo

## 概要比較表

| 特徴 | gll-pg | wagon-gll | rustemo |
|------|--------|-----------|---------|
| **アルゴリズム** | GLL | GLL + WAG | LR(1)/LALR(1)/GLR |
| **開発状態** | アクティブ | 研究プロジェクト | 成熟・安定 |
| **レクサー** | Logos統合 | カスタム | 内蔵 |
| **文法記述** | Rustマクロ | WAGon DSL | 専用文法ファイル |
| **曖昧性処理** | ✓ (全導出) | ✓ (重み付き) | ✓ (GLRモード) |
| **エラー回復** | 基本的 | 基本的 | 高度 |
| **ドキュメント** | 中程度 | 少ない | 充実 |
| **パフォーマンス** | 中程度 | 低い（属性考慮） | 未最適化 |
| **ビルド統合** | proc-macro | コード生成 | build.rs対応 |

## 詳細分析

### 1. gll-pg

**利点：**
- 純粋なGLL実装で、任意の文脈自由文法を扱える
- Logosレクサーとの統合により高速な字句解析
- proc-macroベースで使いやすい
- StreamingIteratorで曖昧な文法の全解析結果を効率的に取得

**欠点：**
- エラー回復機能が基本的
- ドキュメントが限定的
- コミュニティが小さい

**使用例：**
```rust
#[derive(Logos, Debug, Clone, PartialEq)]
enum Token {
    #[token("+")]
    Add,
    #[regex(r"\d+")]
    Number,
}

#[derive(Default)]
struct Parser;

#[gll(S, Token)]
impl Parser {
    #[rule(S -> S Add S)]
    fn add(&self, left: i32, _: Token, right: i32) -> i32 {
        left + right
    }
    
    #[rule(S -> Number)]
    fn number(&self, token: Token) -> i32 {
        // ...
    }
}
```

### 2. wagon-gll

**利点：**
- 重み付き属性文法（WAG）による曖昧性解決
- 研究向けの実験的機能
- 完全なGLL実装

**欠点：**
- パフォーマンスが低い（属性と重みの考慮のため）
- 実用プロジェクトには不向き
- ドキュメントが少ない
- 依存関係が複雑（WAGonエコシステム）

**特徴：**
- 研究者向けのツール
- 言語設計の実験に適している
- 実用性よりも理論的完全性を重視

### 3. rustemo

**利点：**
- 成熟した実装（parglareの経験を活かしている）
- 複数のパーシングアルゴリズム（LR(1)、LALR(1)、GLR）
- 優れたエラー報告（行/列番号）
- レイアウト（コメント、空白）のCFGサポート
- 包括的なドキュメント
- build.rs統合
- Shared Packed Parse Forest (SPPF)
- Elkhound風のLR/GLR切り替え

**欠点：**
- まだ速度最適化されていない
- 専用文法ファイルが必要（.rustemo）
- GLLではなくGLRベース

**使用例：**
```
// calc.rustemo
E: E '+' E | E '*' E | Number;
terminals
Number: /\d+/;
Add: '+';
Mul: '*';
```

```bash
$ rcomp --parser-algo glr calc.rustemo
```

## Vibe言語への適合性評価

### 評価基準
1. **エラー回復能力**：AIフレンドリーなエラーメッセージ生成
2. **拡張性**：エフェクトシステムとの統合
3. **インクリメンタル性**：コンテンツアドレス型コードベースとの相性
4. **パフォーマンス**：実用的な速度
5. **保守性**：長期的なメンテナンス

### 各ツールの評価

#### gll-pg
- ✓ GLLアルゴリズムは論文の推奨に合致
- ✓ proc-macroベースで統合しやすい
- ✗ エラー回復が弱い
- ✗ インクリメンタルパーシング未対応

**適合度：6/10**

#### wagon-gll
- ✓ 理論的に優れたアプローチ
- ✗ 実用性に欠ける
- ✗ パフォーマンスが悪い
- ✗ メンテナンスリスク

**適合度：3/10**

#### rustemo
- ✓ 成熟した実装
- ✓ 優れたエラー報告
- ✓ 豊富な機能（SPPF、レイアウトサポート）
- ✓ 活発な開発
- ✗ GLLではなくGLR（ただし実用上は問題ない）
- ✗ 速度最適化が未完了

**適合度：8/10**

## 推奨案

### 短期的推奨：rustemo

**理由：**
1. **実用性**：最も成熟しており、プロダクション利用に耐える
2. **機能性**：エラー報告、レイアウトサポートなど必要な機能が揃っている
3. **柔軟性**：LR/GLRの切り替えにより、単純な部分は高速に、複雑な部分は完全に解析
4. **統合性**：build.rs統合により既存のビルドプロセスに組み込みやすい

**移行計画：**
1. 現在の手書きパーサーをrustemoの文法ファイルに変換
2. カスタムビルダーでAST生成を制御
3. エラーメッセージをAIフレンドリーに拡張
4. インクリメンタルパーシングのサポートを追加

### 長期的検討：カスタムGLLパーサー

rustemoで基盤を固めた後、以下の理由でカスタムGLLパーサーの開発を検討：

1. **Happy-GLLの知見**を活かしたモジュラー設計
2. **Morpheusの検証機能**の統合
3. **Vibeの特殊要件**（コンテンツアドレス、エフェクトシステム）への最適化

## 結論

現時点では**rustemo**が最も実用的な選択肢。GLRアルゴリズムは実用上GLLと同等の表現力を持ち、より成熟した実装とツールチェーンを提供する。将来的にはVibe言語専用のGLLパーサーの開発も視野に入れるが、まずはrustemoで実用的なパーサーを構築することを推奨する。