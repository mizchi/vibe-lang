これは mizchi の登壇資料の一部です。

---

## LLM とプログラミング言語の相性

- **メジャー言語(ex. TypeScript/Python)の場合**
  - 学習量が多いので初動が安定するが、スケールにやや難
  - 特にランタイム整合性が崩れた時の復旧が難しい
- **コンパイラが厳密な言語(ex. Rust/Haskell)**
  - ブートストラップが遅いが一定量を超えても破綻しづらい印象がある
  - 言語自体の難しさはモデル性能/試行回数/コンパイラの警告品質で(将来的に)踏み倒せる可能性が高そう

---

## 考察: とにかく厳しい言語として Lean 4

- 依存型をもつ純粋関数型の定理証明支援言語
- tactic(戦術) を組み合わせて theorem(定理) を証明する
- 実装手法が正しいかどうかを形式的に検証できる

```hs
-- 「nに0を足してもn」という帰納法を使った証明
theorem add_zero (n : Nat) : n + 0 = n := by
  exact Nat.add_zero n  -- 標準ライブラリの定理を使用
```

---

## 考察：自分の Lean 4 の体験

- **雑な証明体験**:
  - 命題を与えて 15 分ぐらい放置すると確率的に証明されている
  - 出力をみても意味があるのか判断できない！(勉強が足りていないので)
- **わかったこと**
  - 概念を形式的な命題で表現するための訓練がいる(知ってた)
  - その上前提で AI の補助手段として使える可能性がある
    - 「実装対象を形式的に解釈して」「証明しといて」
    - とはいえ、まだモデル性能が足りない
  - AWS の応用例: [AWS と定理証明 〜ポリシー言語 Cedar 開発の舞台裏](https://speakerdeck.com/ytaka23/fp-matsuri-2025)
    - 証明された形式を持つ実装として、参照実装に使う

---

## 考察: 今のプログラミング言語は AI に優しくないのでは

- LSP を叩く MCP を作ってみたが...
  - https://github.com/mizchi/lsmcp
  - AI が直接型チェックや複数ファイルのリネームができる！
  - ワードカウントが下手な AI とファイル操作体系 line:character が噛み合わない
- **人間用のテキスト表現が邪魔**
  - AI はパース済みの構造化データを直接見たほうが(たぶん)いい
  - ファイルに書き込んだ結果ではなく、コンパイラに直接ききたい
  - コード編集単位は AST の木構造に対するコマンド列としたい

---

## 発想を探す: Unison 言語

- 紹介記事: Unison 言語から、「次」の言語を考察したい
  - https://zenn.dev/mizchi/articles/think-next-language-with-unison
- 超訳
  - 言語自体に差分検出とバージョン管理が組み込まれている
  - 純粋関数で環境を固定し、差分検知で型/テストをインクリメンタルに更新
  - 純粋関数の依存と環境が固定されてるなら、テスト結果はキャッシュ可能！

```hs
-- Ability(EffectSystem)
helloWorld : '{IO, Exception} ()
helloWorld _ = printLine "Hello World"
```

---

## 発想を探す: Unison UCM の体験

- ファイルという実体はない
- `ucm> edit helloWorld` すると関連コードが `scratch.u` に展開される
- `scratch.u` というファイルで一旦実装する
- `ucm> update` すると現在の scratch.u がコードベースに取り込まれる
- 内部的にはテキストコードではなく、AST と参照構造だけが保持されている

---

## 発想を探す: Nushell

- https://www.nushell.sh/ POSIX 非互換なシェル
  - 型付きの bash script みたいに使える(TS っぽい)
- 構造化データをパイプで処理できる
  - 例: `ls | weher type == file | sort-by size | reverse`
    - 「ls の結果からファイルで絞って、サイズでソートして、逆順に」
  - 構造化パイプの元ネタは Windows PowerShel
  - bash/zsh はテキストが基本で、構造化データが一級市民ではない
    - 一応 `jq` で出来なくもないが...

---

![bg fit](https://gyazo.com/2d0f2fccdad0266765ef9bbdc562de4f.png)

---

## Git/GitHub も再考したい

- **現代: フォーマッターは git diff のためのもの**
  - フォーマッターが普及して、逆にスタイルに意味が込められなくなった
  - もはやバイナリ AST で保存して、エディタ側で展開していい
- **GitHub(gh) はコミュニケーション層の拡張ストレージ**
  - 今 VCS を設計するならコマンド体系に Issues/PR/Merge を織り込んでよい
- Issues は git notes に変換できないか？
  - Issues や PR の内容は、`git notes` のような VCS 内の情報に格納したい
  - `git notes`: Git の新機能(v2.50.0)でコミットにメモを付与
  - 実装してみた https://github.com/mizchi/git-notes-gh-sync

---

## もし今プログラミング言語を設計するなら...

- **AI 用に構造化された REPL/シェルを与える** (nushell)
  - AI には 人間には厳しいワンライナーを要求していい
    - 例: `> add a:Int b:Int -> Int = { a + b }; test { add 1 2 == 3 }`
  - うまくいったコードを収集して処理に事後的に構造化
- **構造の自己参照ハッシュでコードを保存する** (Unison, Nix)
  - コード検索は型や AST に対するクエリで行う (tree-sitter, ast-grep)
  - テキスト表現は人間用のおまけ
- **実行権限とエフェクト推論を一致させたい** (Deno, Unison, Koka)
  - 例: Deno の実行時パーミッション `deno run --deny-env --allow-ent code.ts`
  - Effect System で副作用の型を追跡して、権限を推論してシェル側に渡す

---

## ...という言語を AI に作らせてみた

- https://github.com/mizchi/x-lang-proto
  - 自分「...という発想で、言語を作って」
  - Claude「わかりました」
  - 自分「この言語どう思う？使いやすい？」
  - Claude「**学術的なおもちゃって感じですね**」
- たぶん、またゼロから書き直します

---

# まとめ

---

## まとめ

- **設計/自動テスト/品質検証のパターンを学ぼう**
  - AI の手数を前提にすると、自動化が成立したときの見返りが大きい
- **人間の生産性とは、AI に良質なアイデアを供給し続ける速度**
  - エコシステムが変化すること前提にアイデアを柔軟に受け止める
  - 自分が言語やエコシステムを考察するのも、その受け入れ準備
- **余談: 最近の悩み**
  - 高速にログを追い続けるので眼精疲労がすごい
  - 「代わりに祈る時間が増えた」ので、エアロバイクを買った

---

# おしまい
